---
layout:     post
title:      Google C++ 编程风格
subtitle:   养成良好的编程习惯和风格，让代码像诗一样优美
date:       2018-04-26
author:     Leosocy
header-img: img/post-bg-black-series-6.jpg
catalog: true
tags:
    - C++
    - Code Style
---

# Google C++ Code Style

C++ 是 Google 大部分开源项目的主要编程语言。正如每个 C++ 程序员都知道的， C++ 有很多强大的特性， 但这种强大不可避免的导致它走向复杂，使代码更容易产生 bug， 难以阅读和维护。

本指南的目的是通过详细阐述 C++ 注意事项来驾驭其复杂性。这些规则在保证代码易于管理的同时， 也能高效使用 C++ 的语言特性。

风格， 亦被称作可读性， 也就是指导 C++ 编程的约定. 使用术语 “风格” 有些用词不当， 因为这些习惯远不止源代码文件格式化这么简单。

使代码易于管理的方法之一是加强代码一致性。让任何程序员都可以快速读懂你的代码这点非常重要。保持统一编程风格并遵守约定意味着可以很容易根据 “模式匹配” 规则来推断各种标识符的含义。创建通用， 必需的习惯用语和模式可以使代码更容易理解。在一些情况下可能有充分的理由改变某些编程风格， 但我们还是应该遵循一致性原则，尽量不这么做。

## 头文件

一个`.cc/.cpp`文件都应该对应一个`.h`文件。也有些常见例外，例如单元测试代码和只包含`main()`入口函数的源文件。

#### Self-contained 头文件

> Tip: 头文件应该能够自给自足（**self-contained**，也就是可以作为第一个头文件被引入），简单来说就是头文件中依赖的其他声明要在头文件中定义清楚，而不能依赖在`.cc`文件中调整引入顺序解决依赖。

如果`.h`文件声明了一个模板或内联函数，同时也在该文件加以定义。凡是有用到这些的`.cc`文件，就得统统包含该头文件，否则程序可能会在构建中链接失败。

有个例外：如果某函数模板为所有相关模板参数显式实例化，或本身就是某类的一个私有成员，那么它就只能定义在实例化该模板的 .cc 文件里。

#### #define保护

> Tip: 所有头文件都应该使用 `#define` 来防止头文件被多重包含， 命名格式当是: `<PROJECT>_<PATH>_<FILE>_H_`。

为保证唯一性， 头文件的命名应该基于所在项目源代码树的全路径. 例如， 项目 `foo`中的头文件`foo/src/bar/baz.h`可按如下方式保护:

```C++
#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_
...
#endif // FOO_BAR_BAZ_H_
```

`#define` 与 `#pragma once`区别

`#pragma once`是编译相关，就是说这个编译系统上能用，但在其他编译系统不一定可以，也就是说移植性差。

所以尽量使用`#ifndef`来避免头文件重复引用。

#### 前置声明

> Tip: 尽可能地**避免使用**前置声明。使用 #include 包含需要的头文件即可。

所谓「前置声明」（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义。

- 优点

    - 前置声明能够节省编译时间，多余的`#include`会迫使编译器展开更多的文件，处理更多的输入。
    - 前置声明能够节省不必要的重新编译的时间。`#include`使代码因为头文件中无关的改动而被重新编译多次。

- 缺点

    - 前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。
    - 前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其API。例如扩大形参类型，加个自带默认参数的模板形参等等。
    - 前置声明来自命名空间 `std::`的symbol时，其**行为未定义**。
    - 很难判断什么时候该用前置声明，什么时候该用`#include`。极端情况下，用前置声明代替`includes`甚至都会暗暗地改变代码的含义：
        ```C++
        // b.h:
        struct B {};
        struct D : B {}

        // good_user.cc:
        #include "b.h"
        void f(B*);
        void f(void*);
        void test(D* x) { f(x); }  // calls f(B*)
        ```
        如果`#include`被 B 和 D 的前置声明替代，`test()`就会调用`f(void*)`。
    - 前置声明了不少来自头文件的symbol时，就会比单单一行的**include冗长**。
    - 仅仅为了能前置声明而重构代码（比如用指针成员代替对象成员）会使代码变得更慢更复杂。

- 结论

    - 尽量避免前置声明那些定义在其他项目中的实体。
    - 函数：总是使用`#include`。
    - 类模板：优先使用`#include`。


#### 内联函数

> Tip: 只有当函数只有**10行甚至更少**时才将其定义为内联函数。

- 定义

    当函数被声明为内联函数之后， 编译器会将其内联展开， 而不是按通常的函数调用机制进行调用。

- 优点

    只要内联的函数体较小， 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短， 性能关键的函数， 鼓励使用内联。

- 缺点

    滥用内联将导致程序变得更慢。内联可能使目标代码量或增或减， 这取决于内联函数的大小。内联非常短小的存取函数通常会减少代码大小， 但内联一个相当大的函数将戏剧性的增加代码大小。现代处理器由于更好的利用了指令缓存， 小巧的代码往往执行更快。

- 结论

    一个较为合理的经验准则是， **不要内联超过10行**的函数。**谨慎对待析构函数**， 析构函数往往比其表面看起来要更长， 因为有隐含的成员和基类析构函数被调用!

    有些函数即使声明为内联的也不一定会被编译器内联， 这点很重要; 比如**虚函数**和**递归函数**就不会被正常内联。通常， 递归函数不应该声明成内联函数，递归调用堆栈的展开并不像循环那么简单， 比如递归层数在编译时可能是未知的， 大多数编译器都不支持内联递归函数。虚函数内联的主要原因则是想把它的函数体放在类定义内， 为了图个方便， 抑或是当作文档描述其行为， 比如精短的存取函数.

#### `#include`的路径及顺序

> Tip: 使用标准的头文件包含顺序可增强可读性， 避免隐藏依赖: 相关头文件， C 库， C++ 库， 其他库的 .h， 本项目内的 .h。

项目内头文件应按照项目源代码目录树结构排列， 避免使用 UNIX 特殊的快捷目录`.`(当前目录)或`..`(上级目录). 例如， `google-awesome-project/src/base/logging.h`应该按如下方式包含:

> `#include "base/logging.h"`

又如，`dir/foo.cc`或`dir/foo_test.cc`的主要作用是实现或测试`dir2/foo2.h`的功能，`foo.cc`中包含头文件的次序如下：

1. `dir2/foo2.h`（优先位置，详情如下）
1. C 系统文件
1. C++ 系统文件
1. 其他库的`.h`文件
1. 本项目内`.h`文件

这种优先的顺序排序保证当`dir2/foo2.h`遗漏某些必要的库时，`dir/foo.cc`或`dir/foo_test.cc`的构建会立刻中止。因此这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是维护其他包的人们。

您所依赖的符号(symbols)被哪些头文件所定义，您就应该包含`(include)`哪些头文件，前置声明(forward declarations)情况除外。比如您要用到`bar.h`中的某个符号， 哪怕您所包含的 `foo.h`已经包含了`bar.h`， 也照样得包含`bar.h`， 除非 `foo.h`有明确说明它会自动向您提供`bar.h`中的symbol。 不过，凡是cc文件所对应的「相关头文件」已经包含的，就不用再重复包含进其cc文件里面了，就像`foo.cc`只包含`foo.h`就够了，不用再管后者所包含的其它内容。

举例来说，`google-awesome-project/src/foo/internal/fooserver.cc`的包含次序如下:

```C++
#include "foo/public/fooserver.h" // 优先位置

#include <sys/types.h>
#include <unistd.h>

#include <hash_map>
#include <vector>

#include "base/basictypes.h"
#include "base/commandlineflags.h"
#include "foo/public/bar.h"
```

#### 小结

1. 避免多重包含
1. 头文件尽量避免使用前置声明，直接`include`
1. 内联函数最好少于10行。类内部的函数一般会自动内联。所以某函数一旦不需要内联，其定义就不要再放在头文件里，而是放到对应的`.cc`文件里
1. 包含文件的次序除了美观之外， 最重要的是可以减少隐藏依赖，使每个头文件在“最需要编译”的地方编译。

## 作用域

#### 命名空间

> Tip: 鼓励在`.cc`文件内使用匿名命名空间或`static`声明. 使用具名的命名空间时，其名称可基于项目名或相对路径。**禁止使用using指示(using-directive e.g. using namespace foo;)**。禁止使用内联命名空间(inline namespace)。

- 定义

    命名空间将全局作用域细分为独立的， 具名的作用域， 可有效防止全局作用域的命名冲突。

- 优点

    类已经提将命名分割在不同类的作用域内， 命名空间在这基础上又封装了一层。

    举例来说， 两个不同项目的全局作用域都有一个类`Foo`， 这样在编译或运行时造成冲突。如果每个项目将代码置于不同命名空间中，`project1::Foo`和`project2::Foo`作为不同符号自然不会冲突。

    内联命名空间会自动把内部的标识符放到外层作用域，比如：

    ```C++
    namespace X {
    inline namespace Y {
    void foo();
    }  // namespace Y
    }  // namespace X
    ```

    `X::Y::foo()`与`X::foo()`彼此可代替。内联命名空间主要用来保持跨版本的 ABI 兼容性。

- 缺点

    命名空间具有迷惑性， 因为它们使得区分两个相同命名所指代的定义更加困难。

    内联命名空间很容易令人迷惑，毕竟其内部的成员不再受其声明所在命名空间的限制。内联命名空间只在大型版本控制里有用。

- 结论

    根据下文将要提到的策略合理使用命名空间。
    - 遵守`命名空间命名`中的规则。
    - 像之前的几个例子中一样，在命名空间的最后注释出命名空间的名字。
    - 用命名空间把文件包含， 以及类的前置声明**以外**的整个源文件封装起来， 以区别于其它命名空间:

        ```C++
        // .h 文件
        namespace mynamespace {

        // 所有声明都置于命名空间中
        // 注意不要使用缩进
        class MyClass {
            public:
            ...
            void Foo();
        };

        } // namespace mynamespace
        ```

        ```C++
        // .cc 文件
        namespace mynamespace {

        // 函数定义都置于命名空间中
        void MyClass::Foo() {
            ...
        }

        } // namespace mynamespace
        ```
    - 不要在命名空间`std`内声明任何东西， 包括标准库的类前置声明。在`std`命名空间声明实体是未定义的行为， 会导致如不可移植。声明标准库下的实体， 需要包含对应的头文件。
    - 不应该使用`using`指示 引入整个命名空间的标识符号。
        ```C++
        // 禁止 —— 污染命名空间
        using namespace foo;
        ```
    - 不要在头文件中使用`命名空间别名`除非显式标记内部命名空间使用。因为任何在头文件中引入的命名空间都会成为公开API的一部分。
    - 禁止用内联命名空间

#### 匿名命名空间和静态变量

> Tip: 在`.cc`文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为`static`。但是不要在`.h`文件中这么做。

- 定义

    所有置于匿名命名空间的声明都具有内部链接性，函数和变量可以经由声明为`static`拥有内部链接性，这意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。

- 结论

    推荐、鼓励在`.cc`中对于不需要在其他地方引用的标识符使用内部链接性声明，但是不要在`.h`中使用。

    匿名命名空间的声明和具名的格式相同，在最后注释上`namespace`:

    ```C++
    namespace {
    ...
    }  // namespace
    ```

#### 非成员函数、静态成员函数和全局函数

> Tip: 使用静态成员函数或命名空间内的非成员函数，尽量不要用裸的全局函数。将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关。

- 优点

    某些情况下，非成员函数和静态成员函数是非常有用的，将非成员函数放在命名空间内可避免污染全局作用域。

- 缺点

    将非成员函数和静态成员函数作为新类的成员或许更有意义，当它们需要访问外部资源或具有重要的依赖关系时更是如此。

- 结论

    有时，把函数的定义同类的实例脱钩是有益的，甚至是必要的。这样的函数可以被定义成静态成员，或是非成员函数。非成员函数不应依赖于外部变量，应尽量置于某个命名空间内。相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类，不如使用`2.1命名空间`。举例而言，对于头文件`myproject/foo_bar.h`，应当使用

    ```C++
    namespace myproject {
    namespace foo_bar {
    void Function1();
    void Function2();
    }  // namespace foo_bar
    }  // namespace myproject
    ```

    而非

    ```C++
    namespace myproject {
    class FooBar {
    public:
    static void Function1();
    static void Function2();
    };
    }  // namespace myproject
    ```

    定义在同一编译单元的函数，被其他编译单元直接调用可能会引入不必要的耦合和链接时依赖；静态成员函数对此尤其敏感。可以考虑提取到新类中，或者将函数置于独立库的命名空间内。

    如果你必须定义非成员函数，又只是在`.cc`文件中使用它，可使用`匿名命名空间`或`static`链接关键字(如`static int Foo() {...}`) 限定其作用域。

#### 局部变量

> Tip: 将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化。

C++允许在函数的任何位置声明变量。我们提倡在尽可能小的作用域中声明变量，离第一次使用越近越好。这使得代码浏览者更容易定位变量声明的位置, 了解变量的类型和初始值。特别是，应使用初始化的方式替代声明再赋值, 比如:

```C++
int i;
i = f(); // 坏——初始化和声明分离
```

```C++
int j = g(); // 好——初始化时声明
```

```C++
vector<int> v;
v.push_back(1); // 用花括号初始化更好
v.push_back(2);
```

```C++
vector<int> v = {1, 2}; // 好——v 一开始就初始化
```

属于`if`,`while`和`for`语句的变量应当在这些语句中正常地声明，这样子这些变量的作用域就被限制在这些语句中了，举例而言:

```C++
while (const char* p = strchr(str, '/')) str = p + 1;
```

有一个例外, 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数。这会导致效率降低。


```C++
// 低效的实现
for (int i = 0; i < 1000000; ++i) {
    Foo f;    // 构造函数和析构函数分别调用 1000000 次!
    f.DoSomething(i);
}
```

```C++
Foo f;    // 构造函数和析构函数只调用 1 次
for (int i = 0; i < 1000000; ++i) {
    f.DoSomething(i);
}
```

#### 静态和全局变量

> Tip: 禁止定义静态储存周期非POD变量，禁止使用含有副作用的函数初始化POD全局变量，因为多编译单元中的静态变量执行时的构造和析构顺序是未明确的，这将导致代码的不可移植。

静态生存周期的对象，即包括了全局变量，静态变量，静态类成员变量和函数静态变量，都必须是原生数据类型`(POD : Plain Old Data)`: 即`int`,`char`和`float`, 以及 POD类型的`指针`、`数组`和`结构体`。

静态变量的构造函数、析构函数和初始化的顺序在`C++`中是只有部分明确的，甚至随着构建变化而变化，导致难以发现的 bug。所以除了禁用类类型的全局变量，我们也不允许用函数返回值来初始化POD 变量，除非该函数（比如 getenv() 或 getpid() ）不涉及任何全局变量。函数作用域里的静态变量除外，毕竟它的初始化顺序是有明确定义的，而且只会在指令执行到它的声明那里才会发生。

综上所述，我们只允许POD类型的静态变量，即**完全禁用**`vector`(使用 C 数组替代) 和`string`(使用`const char []`)。

#### 小结

1. `cc`中的匿名命名空间可避免命名冲突, 限定作用域, 避免直接使用`using`关键字污染命名空间
1. 尽量不用全局函数和全局变量, 考虑作用域和命名空间限制, 尽量单独形成编译单元
1. 多线程中的全局变量 (含静态成员变量) 不要使用`class`类型(含 STL 容器), 避免不明确行为导致的 bug
1. 局部变量在声明的同时进行显式值初始化，比起隐式初始化再赋值的两步过程要高效

## 类

类是 C++ 中代码的基本单元. 显然, 它们被广泛使用. 本节列举了在写一个类时的主要注意事项.

#### 构造函数的职责

- 总述

    不要在构造函数中调用虚函数, 也不要在无法报出错误时进行可能失败的初始化.

- 定义

    在构造函数中可以进行各种初始化操作.

- 优点

    - 无需考虑类是否被初始化
    - 经过构造函数完全初始化后的对象可以为`const`类型, 也能更方便地被标准容器或算法使用

- 缺点

    - 如果在构造函数内调用了自身的虚函数, 这类调用是不会重定向到子类的虚函数实现. 即使当前没有子类化实现, 将来仍是隐患.
    - 如果执行失败, 会得到一个初始化失败的对象, 这个对象有可能进入不正常的状态, 必须使用`bool isValid()`或类似这样的机制才能检查出来, 然而这是一个十分容易被疏忽的方法.
    - 构造函数的地址是无法被取得的, 因此, 举例来说, 由构造函数完成的工作是无法以简单的方式交给其他线程的.

- 结论

    构造函数不允许调用虚函数. 如果代码允许, 直接终止程序是一个合适的处理错误的方式. 否则, 考虑用`Init()`方法或工厂函数.

#### 隐式类型转换

- 总述

    不要定义隐式类型转换. 对于转换运算符和单参数构造函数, 请使用`explicit`关键字.

- 定义

    隐式类型转换允许一个某种类型 (称作 源类型) 的对象被用于需要另一种类型 (称作 目的类型) 的位置, 例如, 将一个`int`类型的参数传递给需要`double`类型的函数.

    `explicit`关键字可以用于构造函数或 (在 C++11 引入) 类型转换运算符, 以保证只有当目的类型在调用点被显式写明时才能进行类型转换,例如使用`cast`. 这不仅作用于隐式类型转换, 还能作用于 C++11 的列表初始化语法:

    ```C++
    class Foo {
        explicit Foo(int x, double y);
        ...
    };

    void Func(Foo f);
    ```

    此时下面的代码是不允许的:

    ```C++
    Func({42, 3.14});  // Error
    ```

    这一代码从技术上说并非隐式类型转换, 但是语言标准认为这是`explicit`应当限制的行为.

- 优点

    - 有时目的类型名是一目了然的, 通过避免显式地写出类型名, 隐式类型转换可以让一个类型的可用性和表达性更强.
    - 隐式类型转换可以简单地取代函数重载.
    - 在初始化对象时, 列表初始化语法是一种简洁明了的写法.

- 缺点

    - 隐式类型转换会隐藏类型不匹配的错误. 有时, 目的类型并不符合用户的期望, 甚至用户根本没有意识到发生了类型转换.
    - 隐式类型转换会让代码难以阅读, 尤其是在有函数重载的时候, 因为这时很难判断到底是哪个函数被调用.
    - 单参数构造函数有可能会被无意地用作隐式类型转换.
    - 如果单参数构造函数没有加上`explicit`关键字, 读者无法判断这一函数究竟是要作为隐式类型转换, 还是作者忘了加上`explicit`标记.
    - 并没有明确的方法用来判断哪个类应该提供类型转换, 这会使得代码变得含糊不清.
    - 如果目的类型是隐式指定的, 那么列表初始化会出现和隐式类型转换一样的问题, 尤其是在列表中只有一个元素的时候.

- 结论

    在类型定义中, 类型转换运算符和单参数构造函数都应当用`explicit`进行标记. 一个例外是, 拷贝和移动构造函数不应当被标记为`explicit`, 因为它们并不执行类型转换.

    不能以一个参数进行调用的构造函数不应当加上`explicit`. 接受一个`std::initializer_list`作为参数的构造函数也应当省略 `explicit`, 以便支持拷贝初始化 (例如`MyType m = {1, 2};`)

#### 可拷贝类型和可移动类型

- 总述

    如果你的类型需要, 就让它们支持拷贝 / 移动. 否则, 就把隐式产生的拷贝和移动函数禁用.

- 定义

    可拷贝类型允许对象在初始化时得到来自相同类型的另一对象的值, 或在赋值时被赋予相同类型的另一对象的值, 同时不改变源对象的值. 对于用户定义的类型, 拷贝操作一般通过拷贝构造函数与拷贝赋值操作符定义. `string`类型就是一个可拷贝类型的例子.

    可移动类型允许对象在初始化时得到来自相同类型的临时对象的值, 或在赋值时被赋予相同类型的临时对象的值 (因此所有可拷贝对象也是可移动的). `std::unique_ptr<int>`就是一个可移动但不可复制的对象的例子. 对于用户定义的类型, 移动操作一般是通过移动构造函数和移动赋值操作符实现的.

    拷贝 / 移动构造函数在某些情况下会被编译器隐式调用. 例如, 通过传值的方式传递对象.

- 优点

    可移动及可拷贝类型的对象可以通过传值的方式进行传递或者返回, 这使得 API 更简单, 更安全也更通用. 与传指针和引用不同, 这样的传递不会造成所有权, 生命周期, 可变性等方面的混乱, 也就没必要在协议中予以明确. 这同时也防止了客户端与实现在非作用域内的交互, 使得它们更容易被理解与维护. 这样的对象可以和需要传值操作的通用 API 一起使用, 例如大多数容器.

    拷贝 / 移动构造函数与赋值操作一般来说要比它们的各种替代方案, 比如`Clone()`, `CopyFrom()` or `Swap()`, 更容易定义, 因为它们能通过编译器产生, 无论是隐式的还是通过`= default`. 这种方式很简洁, 也保证所有数据成员都会被复制. 拷贝与移动构造函数一般也更高效, 因为它们不需要堆的分配或者是单独的初始化和赋值步骤, 同时,对于类似省略不必要的拷贝这样的优化它们也更加合适.

    移动操作允许隐式且高效地将源数据转移出右值对象. 这有时能让代码风格更加清晰.

- 缺点

    许多类型都不需要拷贝, 为它们提供拷贝操作会让人迷惑, 也显得荒谬而不合理. 单件类型(`Registerer`), 与特定的作用域相关的类型 (`Cleanup`), 与其他对象实体紧耦合的类型 (`Mutex`) 从逻辑上来说都不应该提供拷贝操作. 为基类提供拷贝 / 赋值操作是有害的, 因为在使用它们时会造成对象切割. 默认的或者随意的拷贝操作实现可能是不正确的, 这往往导致令人困惑并且难以诊断出的错误.

    拷贝构造函数是隐式调用的, 也就是说, 这些调用很容易被忽略. 这会让人迷惑, 尤其是对那些所用的语言约定或强制要求传引用的程序员来说更是如此. 同时, 这从一定程度上说会鼓励过度拷贝, 从而导致性能上的问题.

- 结论

    如果需要就让你的类型可拷贝 / 可移动. 作为一个经验法则, 如果对于你的用户来说这个拷贝操作不是一眼就能看出来的, 那就不要把类型设置为可拷贝. 如果让类型可拷贝, 一定要同时给出拷贝构造函数和赋值操作的定义, 反之亦然. 如果让类型可拷贝, 同时移动操作的效率高于拷贝操作, 那么就把移动的两个操作 (移动构造函数和赋值操作) 也给出定义. 如果类型不可拷贝, 但是移动操作的正确性对用户显然可见, 那么把这个类型设置为只可移动并定义移动的两个操作.

    如果定义了拷贝/移动操作, 则要保证这些操作的默认实现是正确的. 记得时刻检查默认操作的正确性, 并且在文档中说明类是可拷贝的且/或可移动的.

    ```C++
    class Foo {
    public:
        Foo(Foo&& other) : field_(other.field) {}
        // 差, 只定义了移动构造函数, 而没有定义对应的赋值运算符.

    private:
        Field field_;
    };
    ```

    由于存在对象切割的风险, 不要为任何有可能有派生类的对象提供赋值操作或者拷贝 / 移动构造函数 (当然也不要继承有这样的成员函数的类). 如果你的基类需要可复制属性, 请提供一个`public virtual Clone()`和一个`protected`的拷贝构造函数以供派生类实现.

    如果你的类不需要拷贝 / 移动操作, 请显式地通过在`public`域中使用`= delete`或其他手段禁用之.

    ```C++
    // MyClass is neither copyable nor movable.
    MyClass(const MyClass&) = delete;
    MyClass& operator=(const MyClass&) = delete;
    ```

#### 结构体 VS 类

- 总述

    仅当只有数据成员时使用`struct`, 其它一概使用`class`.

- 说明

    在 C++ 中`struct`和`class`关键字几乎含义一样. 我们为这两个关键字添加我们自己的语义理解, 以便为定义的数据类型选择合适的关键字.

    `struct`用来定义包含数据的被动式对象, 也可以包含相关的常量, 但除了存取数据成员之外, 没有别的函数功能. 并且存取功能是通过直接访问位域, 而非函数调用. 除了构造函数, 析构函数, `Initialize()`, `Reset()`, `Validate()` 等类似的用于设定数据成员的函数外, 不能提供其它功能的函数.

    如果需要更多的函数功能, `class`更适合. 如果拿不准, 就用 `class`.

    为了和STL保持一致, 对于仿函数等特性可以不用`class`而是使用`struct`.

    注意: 类和结构体的成员变量使用不同的命名规则.

#### 继承

- 总述

    使用组合常常比使用继承更合理. 如果使用继承的话, 定义为 public 继承.

- 定义

    当子类继承基类时, 子类包含了父基类所有数据及操作的定义. C++ 实践中, 继承主要用于两种场合: 实现继承, 子类继承父类的实现代码; 接口继承, 子类仅继承父类的方法名称.

- 优点

    实现继承通过原封不动的复用基类代码减少了代码量. 由于继承是在编译时声明, 程序员和编译器都可以理解相应操作并发现错误. 从编程角度而言, 接口继承是用来强制类输出特定的 API. 在类没有实现 API 中某个必须的方法时, 编译器同样会发现并报告错误.

- 缺点

    对于实现继承, 由于子类的实现代码散布在父类和子类间之间, 要理解其实现变得更加困难. 子类不能重写父类的非虚函数, 当然也就不能修改其实现. 基类也可能定义了一些数据成员, 因此还必须区分基类的实际布局.

- 结论

    所有继承必须是`public`的. 如果你想使用私有继承, 你应该替换成把基类的实例作为成员对象的方式.

    不要过度使用实现继承. 组合常常更合适一些. 尽量做到只在 “是一个” (“is-a”, 其他 “has-a” 情况下请使用组合) 的情况下使用继承: 如果`Bar`的确 “是一种” `Foo`, `Bar`才能继承`Foo`.

    必要的话, 析构函数声明为`virtual`. 如果你的类有虚函数, 则析构函数也应该为虚函数.

    对于可能被子类访问的成员函数, 不要过度使用`protected`关键字. 注意, 数据成员都必须是**私有的**.

    对于重载的虚函数或虚析构函数, 使用`override`, 或 (较不常用的)`final`关键字显式地进行标记. 较早 (早于 C++11) 的代码可能会使用`virtual`关键字作为不得已的选项. 因此, 在声明重载时, 请使用 `override`, `final`或`virtual`的其中之一进行标记. 标记为`override`或`final`的析构函数如果不是对基类虚函数的重载的话, 编译会报错, 这有助于捕获常见的错误. 这些标记起到了文档的作用, 因为如果省略这些关键字, 代码阅读者不得不检查所有父类, 以判断该函数是否是虚函数.

#### 多重继承

- 总述

    真正需要用到多重实现继承的情况少之又少. 只在以下情况我们才允许多重继承: 最多只有一个基类是非抽象类; 其它基类都是以`Interface`为后缀的纯接口类.

- 定义

    多重继承允许子类拥有多个基类. 要将作为*纯接口*的基类和具有*实现*的基类区别开来.

- 优点

    相比单继承, 多重实现继承可以复用更多的代码.

- 缺点

    真正需要用到多重 实现 继承的情况少之又少. 有时多重实现继承看上去是不错的解决方案, 但这时你通常也可以找到一个更明确, 更清晰的不同解决方案.

- 结论

    只有当所有父类除第一个外都是*纯接口类*时, 才允许使用多重继承. 为确保它们是纯接口, 这些类必须以`Interface`为后缀.

#### 接口

- 总述

    接口是指满足特定条件的类, 这些类以`Interface`为后缀 (不强制).

- 定义

    当一个类满足以下要求时, 称之为纯接口:

    - 只有纯虚函数 (“`=0`”) 和静态函数 (除了下文提到的析构函数).
    - 没有非静态数据成员.
    - 没有定义任何构造函数. 如果有, 也不能带有参数, 并且必须为`protected`.
    - 如果它是一个子类, 也只能从满足上述条件并以`Interface`为后缀的类继承.

    接口类不能被直接实例化, 因为它声明了纯虚函数. 为确保接口类的所有实现可被正确销毁, 必须为之声明虚析构函数

- 优点

    以`Interface`为后缀可以提醒其他人不要为该接口类增加函数实现或非静态数据成员. 这一点对于`多重继承`尤其重要.

- 缺点

    `Interface`后缀增加了类名长度, 为阅读和理解带来不便. 同时, 接口属性作为实现细节不应暴露给用户.

- 结论

    只有在满足上述条件时, 类才以`Interface`结尾, 但反过来, 满足上述需要的类未必一定以`Interface`结尾.

#### 运算符重载

- 总述

    除少数特定环境外, 不要重载运算符. 也不要创建用户定义字面量.

- 定义

    C++ 允许用户通过使用`operator`关键字对内建运算符进行重载定义, 只要其中一个参数是用户定义的类型. `operator`关键字还允许用户使用`operator""`定义新的字面运算符, 并且定义类型转换函数, 例如`operator bool()`.

- 优点

    重载运算符可以让代码更简洁易懂, 也使得用户定义的类型和内建类型拥有相似的行为. 重载运算符对于某些运算来说是符合符合语言习惯的名称 (例如`==`,`<`,`=`,`<<`), 遵循这些语言约定可以让用户定义的类型更易读, 也能更好地和需要这些重载运算符的函数库进行交互操作.

    对于创建用户定义的类型的对象来说, 用户定义字面量是一种非常简洁的标记.

- 缺点

    - 要提供正确, 一致, 不出现异常行为的操作符运算需要花费不少精力, 而且如果达不到这些要求的话, 会导致令人迷惑的 Bug.
    - 过度使用运算符会带来难以理解的代码, 尤其是在重载的操作符的语义与通常的约定不符合时.
    - 函数重载有多少弊端, 运算符重载就至少有多少.
    - 运算符重载会混淆视听, 让你误以为一些耗时的操作和操作内建类型一样轻巧.
    - 对重载运算符的调用点的查找需要的可就不仅仅是像 grep 那样的程序了, 这时需要能够理解 C++ 语法的搜索工具.
    - 重载某些运算符本身就是有害的. 例如, 重载一元运算符 & 会导致同样的代码有完全不同的含义, 这取决于重载的声明对某段代码而言是否是可见的. 重载诸如`&&`,`||`和`,` 会导致运算顺序和内建运算的顺序不一致.

- 结论

    只有在意义明显, 不会出现奇怪的行为并且与对应的内建运算符的行为一致时才定义重载运算符. 例如, | 要作为位或或逻辑或来使用, 而不是作为 shell 中的管道.

    只有对用户自己定义的类型重载运算符. 更准确地说, 将它们和它们所操作的类型定义在同一个头文件中, `.cc`中和命名空间中. 这样做无论类型在哪里都能够使用定义的运算符, 并且最大程度上避免了多重定义的风险. 如果可能的话, 请避免将运算符定义为模板, 因为此时它们必须对任何模板参数都能够作用. 如果你定义了一个运算符, 请将其相关且有意义的运算符都进行定义, 并且保证这些定义的语义是一致的. 例如, 如果你重载了`<`, 那么请将所有的比较运算符都进行重载, 并且保证对于同一组参数,`<`和`>`不会同时返回`true`.

    不要为了避免重载操作符而走极端. 比如说, 应当定义`==`,`=`,和`<<`而不是`Equals()`,`CopyFrom()`和`PrintTo()`. 反过来说, 不要只是为了满足函数库需要而去定义运算符重载. 比如说, 如果你的类型没有自然顺序, 而你要将它们存入`std::set`中, 最好还是定义一个自定义的比较运算符而不是重载`<`.

    不要重载`&&`,`||`,`,`或一元运算符`&`. 不要重载`operator""`, 也就是说, 不要引入用户定义字面量.

#### 存取控制

- 总述

    将*所有*数据成员声明为`private`, 除非是`static const`类型成员 (遵循 常量命名规则). 处于技术上的原因, 在使用`Google Test`时我们允许测试固件类中的数据成员为`protected`.

#### 声明顺序

- 总述

    将相似的声明放在一起, 将`public`部分放在最前.

- 说明

    类定义一般应以`public:`开始, 后跟`protected:`, 最后是`private:`. 省略空部分.

    在各个部分中, 建议将类似的声明放在一起, 并且建议以如下的顺序: 类型 (包括`typedef`,`using`和嵌套的结构体与类), 常量, 工厂函数, 构造函数, 赋值运算符, 析构函数, 其它函数, 数据成员.

    不要将大段的函数定义内联在类定义中. 通常，只有那些普通的, 或性能关键且短小的函数可以内联在类定义中. 参见 内联函数 一节.

#### 小结

1. 不在构造函数中做太多逻辑相关的初始化
1. 编译器提供的默认构造函数不会对变量进行初始化, 如果定义了其他构造函数, 编译器不再提供, 需要编码者自行提供默认构造函数
1. 为避免隐式转换, 需将单参数构造函数声明为`explicit`
1. 为避免拷贝构造函数, 赋值操作的滥用和编译器自动生成, 可将其声明为`private`且无需实现
1. 仅在作为数据集合时使用`struct`
1. 组合 > 实现继承 > 接口继承 > 私有继承, 子类重载的虚函数也要声明`virtual`关键字, 虽然编译器允许不这样做
1. 避免使用多重继承, 使用时, 除一个基类含有实现外, 其他基类均为纯接口
1. 接口类类名以`Interface`为后缀, 除提供带实现的虚析构函数, 静态成员函数外, 其他均为纯虚函数, 不定义非静态数据成员, 不提供构造函数, 提供的话, 声明为`protected`
1. 为降低复杂性, 尽量不重载操作符, 模板, 标准类中使用时提供文档说明
1. 存取函数一般内联在头文件中
1. 声明次序:`public` -> `protected` -> `private`
1. 函数体尽量短小, 紧凑, 功能单一

## 函数

#### 参数顺序

- 总述

    函数的参数顺序为: 输入参数在先, 后跟输出参数.

- 说明

    C/C++ 中的函数参数或者是函数的输入, 或者是函数的输出, 或兼而有之. 输入参数通常是值参或`const`引用, 输出参数或输入/输出参数则一般为非`const`指针. 在排列参数顺序时, 将所有的输入参数置于输出参数之前. 特别要注意, 在加入新参数时不要因为它们是新参数就置于参数列表最后, 而是仍然要按照前述的规则, 即将新的输入参数也置于输出参数之前.

    这并非一个硬性规定. 输入/输出参数 (通常是类或结构体) 让这个问题变得复杂. 并且, 有时候为了其他函数保持一致, 你可能不得不有所变通.

#### 编写简短函数

- 总述

    我们倾向于编写简短, 凝练的函数.

- 说明

    我们承认长函数有时是合理的, 因此并不硬性限制函数的长度. 如果函数超过`40`行, 可以思索一下能不能在不影响程序结构的前提下对其进行分割.

    即使一个长函数现在工作的非常好, 一旦有人对其修改, 有可能出现新的问题, 甚至导致难以发现的 bug. 使函数尽量简短,以便于他人阅读和修改代码.

    在处理代码时, 你可能会发现复杂的长函数. 不要害怕修改现有代码: 如果证实这些代码使用/调试起来很困难, 或者你只需要使用其中的一小段代码, 考虑将其分割为更加简短并易于管理的若干函数.

#### 引用参数

- 总述

    所有按引用传递的参数必须加上`const`.

- 定义

    在 C 语言中, 如果函数需要修改变量的值, 参数必须为指针, 如`int foo(int *pval)`. 在 C++ 中, 函数还可以声明为引用参数: `int foo(int &val)`.

- 优点

    定义引用参数可以防止出现`(*pval)++`这样丑陋的代码. 引用参数对于拷贝构造函数这样的应用也是必需的. 同时也更明确地不接受空指针.

- 缺点

    容易引起误解, 因为引用在语法上是值变量却拥有指针的语义.

- 结论

    函数参数列表中, 所有引用参数都必须是`const`:

    ```C++
    void Foo(const string &in, string *out);
    ```

    事实上这在Google Code是一个硬性约定: 输入参数是值参或`const`引用, 输出参数为指针. 输入参数可以是`const`指针, 但决不能是非`const`的引用参数, 除非特殊要求, 比如 swap().

    有时候, 在输入形参中用`const T*`指针比`const T&`更明智. 比如:

    - 可能会传递空指针.
    - 函数要把指针或对地址的引用赋值给输入形参.

    总而言之, 大多时候输入形参往往是`const T&`. 若用`const T*`则说明输入另有处理. 所以若要使用`const T*`, 则应给出相应的理由, 否则会使得读者感到迷惑.

#### 函数重载

- 总述

    若要使用函数重载, 则必须能让读者一看调用点就胸有成竹, 而不用花心思猜测调用的重载函数到底是哪一种. 这一规则也适用于构造函数.

- 定义

    你可以编写一个参数类型为`const string&`的函数, 然后用另一个参数类型为`const char*`的函数对其进行重载:

    ```C++
    class MyClass {
        public:
        void Analyze(const string &text);
        void Analyze(const char *text, size_t textlen);
    };
    ```

- 优点

    通过重载参数不同的同名函数, 可以令代码更加直观. 模板化代码需要重载, 这同时也能为使用者带来便利.

- 缺点

    如果函数单靠不同的参数类型而重载, 读者就得十分熟悉 C++ 五花八门的匹配规则, 以了解匹配过程具体到底如何. 另外, 如果派生类只重载了某个函数的部分变体, 继承语义就容易令人困惑.

- 结论

    如果打算重载一个函数, 可以试试改在函数名里加上参数信息. 例如, 用`AppendString()`和`AppendInt()`等, 而不是一口气重载多个`Append()`. 如果重载函数的目的是为了支持不同数量的同一类型参数, 则优先考虑使用`std::vector`以便使用者可以用 列表初始化 指定参数.

#### 缺省参数

- 总述

    只允许在非虚函数中使用缺省参数, 且必须保证缺省参数的值始终一致. 缺省参数与 函数重载 遵循同样的规则. 一般情况下建议使用函数重载, 尤其是在缺省函数带来的可读性提升不能弥补下文中所提到的缺点的情况下.

- 优点

    有些函数一般情况下使用默认参数, 但有时需要又使用非默认的参数. 缺省参数为这样的情形提供了便利, 使程序员不需要为了极少的例外情况编写大量的函数. 和函数重载相比, 缺省参数的语法更简洁明了, 减少了大量的样板代码, 也更好地区别了 “必要参数” 和 “可选参数”.

- 缺点

    缺省参数实际上是函数重载语义的另一种实现方式, 因此所有 不应当使用函数重载的理由 也都适用于缺省参数.

    虚函数调用的缺省参数取决于目标对象的静态类型, 此时无法保证给定函数的所有重载声明的都是同样的缺省参数.

    缺省参数是在每个调用点都要进行重新求值的, 这会造成生成的代码迅速膨胀. 作为读者, 一般来说也更希望缺省的参数在声明时就已经被固定了, 而不是在每次调用时都可能会有不同的取值.

    缺省参数会干扰函数指针, 导致函数签名与调用点的签名不一致. 而函数重载不会导致这样的问题.

- 结论

    对于虚函数, 不允许使用缺省参数, 因为在虚函数中缺省参数不一定能正常工作. 如果在每个调用点缺省参数的值都有可能不同, 在这种情况下缺省函数也不允许使用. (例如, 不要写像`void f(int n = counter++);` 这样的代码.)

    在其他情况下, 如果缺省参数对可读性的提升远远超过了以上提及的缺点的话, 可以使用缺省参数. 如果仍有疑惑, 就使用函数重载.


## 来自Google的奇技

Google 用了很多自己实现的技巧 / 工具使 C++ 代码更加健壮, 我们使用 C++ 的方式可能和你在其它地方见到的有所不同.

#### 所有权与智能指针

- 总述

    动态分配出的对象最好有单一且固定的所有主, 并通过智能指针传递所有权.

- 定义

    所有权是一种登记／管理动态内存和其它资源的技术. 动态分配对象的所有主是一个对象或函数, 后者负责确保当前者无用时就自动销毁前者. 所有权有时可以共享, 此时就由最后一个所有主来负责销毁它. 甚至也可以不用共享, 在代码中直接把所有权传递给其它对象.

    智能指针是一个通过重载`*`和`->`运算符以表现得如指针一样的类. 智能指针类型被用来自动化所有权的登记工作, 来确保执行销毁义务到位.`std::unique_ptr`是 C++11 新推出的一种智能指针类型, 用来表示动态分配出的对象的独一无二的所有权; 当`std::unique_ptr`离开作用域时, 对象就会被销毁.`std::unique_ptr`不能被复制, 但可以把它移动（move）给新所有主.`std::shared_ptr`同样表示动态分配对象的所有权, 但可以被共享, 也可以被复制; 对象的所有权由所有复制者共同拥有, 最后一个复制者被销毁时, 对象也会随着被销毁.

- 优点

    - 如果没有清晰、逻辑条理的所有权安排, 不可能管理好动态分配的内存.
    - 传递对象的所有权, 开销比复制来得小, 如果可以复制的话.
    - 传递所有权也比”借用”指针或引用来得简单, 毕竟它大大省去了两个用户一起协调对象生命周期的工作.
    - 如果所有权逻辑条理, 有文档且不紊乱的话, 可读性会有很大提升.
    - 可以不用手动完成所有权的登记工作, 大大简化了代码, 也免去了一大波错误之恼.
    - 对于 const 对象来说, 智能指针简单易用, 也比深度复制高效.

- 缺点

    - 不得不用指针（不管是智能的还是原生的）来表示和传递所有权. 指针语义可要比值语义复杂得许多了, 特别是在 API 里：这时不光要操心所有权, 还要顾及别名, 生命周期, 可变性以及其它大大小小的问题.
    - 其实值语义的开销经常被高估, 所以所有权传递带来的性能提升不一定能弥补可读性和复杂度的损失.
    - 如果 API 依赖所有权的传递, 就会害得客户端不得不用单一的内存管理模型.
    - 如果使用智能指针, 那么资源释放发生的位置就会变得不那么明显.
    - `std::unique_ptr`的所有权传递原理是 C++11 的 move 语法, 后者毕竟是刚刚推出的, 容易迷惑程序员.
    - 如果原本的所有权设计已经够完善了, 那么若要引入所有权共享机制, 可能不得不重构整个系统.
    - 所有权共享机制的登记工作在运行时进行, 开销可能相当大.
    - 某些极端情况下 (例如循环引用), 所有权被共享的对象永远不会被销毁.
    - 智能指针并不能够完全代替原生指针.

- 结论

    如果必须使用动态分配, 那么更倾向于将所有权保持在分配者手中. 如果其他地方要使用这个对象, 最好传递它的拷贝, 或者传递一个不用改变所有权的指针或引用. 倾向于使用`std::unique_ptr`来明确所有权传递, 例如：

    ```C++
    std::unique_ptr<Foo> FooFactory();
    void FooConsumer(std::unique_ptr<Foo> ptr);
    ```

    如果没有很好的理由, 则不要使用共享所有权. 这里的理由可以是为了避免开销昂贵的拷贝操作, 但是只有当性能提升非常明显, 并且操作的对象是不可变的（比如说`std::shared_ptr<const Foo>`）时候, 才能这么做. 如果确实要使用共享所有权, 建议于使用`std::shared_ptr`.

    不要使用`std::auto_ptr`, 使用`std::unique_ptr`代替它.

#### Cpplint

- 总述

    使用`cpplint.py`检查风格错误.

- 说明

    `cpplint.py`是一个用来分析源文件, 能检查出多种风格错误的工具. 它不并完美, 甚至还会漏报和误报, 但它仍然是一个非常有用的工具. 在行尾加`// NOLINT`, 或在上一行加`// NOLINTNEXTLINE`, 可以忽略报错.

    某些项目会指导你如何使用他们的项目工具运行`cpplint.py`. 如果你参与的项目没有提供, 你可以单独下载`cpplint.py`.