---
layout:     post
title:      Google C++ 编程风格
subtitle:   养成良好的编程习惯和风格，让代码像诗一样优美
date:       2018-04-26
author:     Leosocy
header-img: img/post-bg-black-series-6.jpg
catalog: true
tags:
    - C++
    - Code Style
---

# Google C++ Code Style

C++ 是 Google 大部分开源项目的主要编程语言。正如每个 C++ 程序员都知道的, C++ 有很多强大的特性, 但这种强大不可避免的导致它走向复杂，使代码更容易产生 bug, 难以阅读和维护。

本指南的目的是通过详细阐述 C++ 注意事项来驾驭其复杂性。这些规则在保证代码易于管理的同时, 也能高效使用 C++ 的语言特性。

风格, 亦被称作可读性, 也就是指导 C++ 编程的约定. 使用术语 “风格” 有些用词不当, 因为这些习惯远不止源代码文件格式化这么简单。

使代码易于管理的方法之一是加强代码一致性。让任何程序员都可以快速读懂你的代码这点非常重要。保持统一编程风格并遵守约定意味着可以很容易根据 “模式匹配” 规则来推断各种标识符的含义。创建通用, 必需的习惯用语和模式可以使代码更容易理解。在一些情况下可能有充分的理由改变某些编程风格, 但我们还是应该遵循一致性原则，尽量不这么做。

## 头文件

一个`.cc/.cpp`文件都应该对应一个`.h`文件。也有些常见例外，例如单元测试代码和只包含`main()`入口函数的源文件。

#### Self-contained 头文件

头文件应该能够自给自足（**self-contained**,也就是可以作为第一个头文件被引入），简单来说就是头文件中依赖的其他声明要在头文件中定义清楚，而不能依赖在`.cc`文件中调整引入顺序解决依赖。

如果`.h`文件声明了一个模板或内联函数，同时也在该文件加以定义。凡是有用到这些的`.cc`文件，就得统统包含该头文件，否则程序可能会在构建中链接失败。

有个例外：如果某函数模板为所有相关模板参数显式实例化，或本身就是某类的一个私有成员，那么它就只能定义在实例化该模板的 .cc 文件里。

#### #define保护

> Tip: 所有头文件都应该使用 `#define` 来防止头文件被多重包含, 命名格式当是: `<PROJECT>_<PATH>_<FILE>_H_`。

为保证唯一性, 头文件的命名应该基于所在项目源代码树的全路径. 例如, 项目 `foo`中的头文件`foo/src/bar/baz.h`可按如下方式保护:

```C++
#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_
...
#endif // FOO_BAR_BAZ_H_
```

`#define` 与 `#pragma once`区别

`#pragma once`是编译相关，就是说这个编译系统上能用，但在其他编译系统不一定可以，也就是说移植性差。

所以尽量使用`#ifndef`来避免头文件重复引用。

#### 前置声明

> Tip: 尽可能地**避免使用**前置声明。使用 #include 包含需要的头文件即可。

所谓「前置声明」（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义。

- 优点

    - 前置声明能够节省编译时间，多余的`#include`会迫使编译器展开更多的文件，处理更多的输入。
    - 前置声明能够节省不必要的重新编译的时间。`#include`使代码因为头文件中无关的改动而被重新编译多次。

- 缺点

    - 前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。
    - 前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其API。例如扩大形参类型，加个自带默认参数的模板形参等等。
    - 前置声明来自命名空间 `std::`的symbol时，其**行为未定义**。
    - 很难判断什么时候该用前置声明，什么时候该用`#include`。极端情况下，用前置声明代替`includes`甚至都会暗暗地改变代码的含义：
        ```C++
        // b.h:
        struct B {};
        struct D : B {}

        // good_user.cc:
        #include "b.h"
        void f(B*);
        void f(void*);
        void test(D* x) { f(x); }  // calls f(B*)
        ```
        如果`#include`被 B 和 D 的前置声明替代，`test()`就会调用`f(void*)`。
    - 前置声明了不少来自头文件的symbol时，就会比单单一行的**include冗长**。
    - 仅仅为了能前置声明而重构代码（比如用指针成员代替对象成员）会使代码变得更慢更复杂。

- 结论

    - 尽量避免前置声明那些定义在其他项目中的实体。
    - 函数：总是使用`#include`。
    - 类模板：优先使用`#include`。

至于什么时候包含头文件，参见[1.5 #iclude路径及顺序](#15)的路径及顺序。

#### 内联函数

> Tip: 只有当函数只有10行甚至更少时才将其定义为内联函数。

- 定义：
    当函数被声明为内联函数之后, 编译器会将其内联展开, 而不是按通常的函数调用机制进行调用。

#### <h2 id="15">**`#include`** 的路径及顺序</h2>