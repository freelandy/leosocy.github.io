---
layout:     post
title:      Google C++ 编程风格
subtitle:   养成良好的编程习惯和风格，让代码像诗一样优美
date:       2018-04-26
author:     Leosocy
header-img: img/post-bg-black-series-6.jpg
catalog: true
tags:
    - C++
    - Code Style
---

# Google C++ Code Style

C++ 是 Google 大部分开源项目的主要编程语言。正如每个 C++ 程序员都知道的， C++ 有很多强大的特性， 但这种强大不可避免的导致它走向复杂，使代码更容易产生 bug， 难以阅读和维护。

本指南的目的是通过详细阐述 C++ 注意事项来驾驭其复杂性。这些规则在保证代码易于管理的同时， 也能高效使用 C++ 的语言特性。

风格， 亦被称作可读性， 也就是指导 C++ 编程的约定. 使用术语 “风格” 有些用词不当， 因为这些习惯远不止源代码文件格式化这么简单。

使代码易于管理的方法之一是加强代码一致性。让任何程序员都可以快速读懂你的代码这点非常重要。保持统一编程风格并遵守约定意味着可以很容易根据 “模式匹配” 规则来推断各种标识符的含义。创建通用， 必需的习惯用语和模式可以使代码更容易理解。在一些情况下可能有充分的理由改变某些编程风格， 但我们还是应该遵循一致性原则，尽量不这么做。

## 头文件

一个`.cc/.cpp`文件都应该对应一个`.h`文件。也有些常见例外，例如单元测试代码和只包含`main()`入口函数的源文件。

#### Self-contained 头文件

> Tip: 头文件应该能够自给自足（**self-contained**，也就是可以作为第一个头文件被引入），简单来说就是头文件中依赖的其他声明要在头文件中定义清楚，而不能依赖在`.cc`文件中调整引入顺序解决依赖。

如果`.h`文件声明了一个模板或内联函数，同时也在该文件加以定义。凡是有用到这些的`.cc`文件，就得统统包含该头文件，否则程序可能会在构建中链接失败。

有个例外：如果某函数模板为所有相关模板参数显式实例化，或本身就是某类的一个私有成员，那么它就只能定义在实例化该模板的 .cc 文件里。

#### #define保护

> Tip: 所有头文件都应该使用 `#define` 来防止头文件被多重包含， 命名格式当是: `<PROJECT>_<PATH>_<FILE>_H_`。

为保证唯一性， 头文件的命名应该基于所在项目源代码树的全路径. 例如， 项目 `foo`中的头文件`foo/src/bar/baz.h`可按如下方式保护:

```C++
#ifndef FOO_BAR_BAZ_H_
#define FOO_BAR_BAZ_H_
...
#endif // FOO_BAR_BAZ_H_
```

`#define` 与 `#pragma once`区别

`#pragma once`是编译相关，就是说这个编译系统上能用，但在其他编译系统不一定可以，也就是说移植性差。

所以尽量使用`#ifndef`来避免头文件重复引用。

#### 前置声明

> Tip: 尽可能地**避免使用**前置声明。使用 #include 包含需要的头文件即可。

所谓「前置声明」（forward declaration）是类、函数和模板的纯粹声明，没伴随着其定义。

- 优点

    - 前置声明能够节省编译时间，多余的`#include`会迫使编译器展开更多的文件，处理更多的输入。
    - 前置声明能够节省不必要的重新编译的时间。`#include`使代码因为头文件中无关的改动而被重新编译多次。

- 缺点

    - 前置声明隐藏了依赖关系，头文件改动时，用户的代码会跳过必要的重新编译过程。
    - 前置声明可能会被库的后续更改所破坏。前置声明函数或模板有时会妨碍头文件开发者变动其API。例如扩大形参类型，加个自带默认参数的模板形参等等。
    - 前置声明来自命名空间 `std::`的symbol时，其**行为未定义**。
    - 很难判断什么时候该用前置声明，什么时候该用`#include`。极端情况下，用前置声明代替`includes`甚至都会暗暗地改变代码的含义：
        ```C++
        // b.h:
        struct B {};
        struct D : B {}

        // good_user.cc:
        #include "b.h"
        void f(B*);
        void f(void*);
        void test(D* x) { f(x); }  // calls f(B*)
        ```
        如果`#include`被 B 和 D 的前置声明替代，`test()`就会调用`f(void*)`。
    - 前置声明了不少来自头文件的symbol时，就会比单单一行的**include冗长**。
    - 仅仅为了能前置声明而重构代码（比如用指针成员代替对象成员）会使代码变得更慢更复杂。

- 结论

    - 尽量避免前置声明那些定义在其他项目中的实体。
    - 函数：总是使用`#include`。
    - 类模板：优先使用`#include`。


#### 内联函数

> Tip: 只有当函数只有**10行甚至更少**时才将其定义为内联函数。

- 定义

    当函数被声明为内联函数之后， 编译器会将其内联展开， 而不是按通常的函数调用机制进行调用。

- 优点

    只要内联的函数体较小， 内联该函数可以令目标代码更加高效. 对于存取函数以及其它函数体比较短， 性能关键的函数， 鼓励使用内联。

- 缺点

    滥用内联将导致程序变得更慢。内联可能使目标代码量或增或减， 这取决于内联函数的大小。内联非常短小的存取函数通常会减少代码大小， 但内联一个相当大的函数将戏剧性的增加代码大小。现代处理器由于更好的利用了指令缓存， 小巧的代码往往执行更快。

- 结论

    一个较为合理的经验准则是， **不要内联超过10行**的函数。**谨慎对待析构函数**， 析构函数往往比其表面看起来要更长， 因为有隐含的成员和基类析构函数被调用!

    有些函数即使声明为内联的也不一定会被编译器内联， 这点很重要; 比如**虚函数**和**递归函数**就不会被正常内联。通常， 递归函数不应该声明成内联函数，递归调用堆栈的展开并不像循环那么简单， 比如递归层数在编译时可能是未知的， 大多数编译器都不支持内联递归函数。虚函数内联的主要原因则是想把它的函数体放在类定义内， 为了图个方便， 抑或是当作文档描述其行为， 比如精短的存取函数.

#### `#include`的路径及顺序

> Tip: 使用标准的头文件包含顺序可增强可读性， 避免隐藏依赖: 相关头文件， C 库， C++ 库， 其他库的 .h， 本项目内的 .h。

项目内头文件应按照项目源代码目录树结构排列， 避免使用 UNIX 特殊的快捷目录`.`(当前目录)或`..`(上级目录). 例如， `google-awesome-project/src/base/logging.h`应该按如下方式包含:

> `#include "base/logging.h"`

又如，`dir/foo.cc`或`dir/foo_test.cc`的主要作用是实现或测试`dir2/foo2.h`的功能，`foo.cc`中包含头文件的次序如下：

1. `dir2/foo2.h`（优先位置，详情如下）
1. C 系统文件
1. C++ 系统文件
1. 其他库的`.h`文件
1. 本项目内`.h`文件

这种优先的顺序排序保证当`dir2/foo2.h`遗漏某些必要的库时，`dir/foo.cc`或`dir/foo_test.cc`的构建会立刻中止。因此这一条规则保证维护这些文件的人们首先看到构建中止的消息而不是维护其他包的人们。

您所依赖的符号(symbols)被哪些头文件所定义，您就应该包含`(include)`哪些头文件，前置声明(forward declarations)情况除外。比如您要用到`bar.h`中的某个符号， 哪怕您所包含的 `foo.h`已经包含了`bar.h`， 也照样得包含`bar.h`， 除非 `foo.h`有明确说明它会自动向您提供`bar.h`中的symbol。 不过，凡是cc文件所对应的「相关头文件」已经包含的，就不用再重复包含进其cc文件里面了，就像`foo.cc`只包含`foo.h`就够了，不用再管后者所包含的其它内容。

举例来说，`google-awesome-project/src/foo/internal/fooserver.cc`的包含次序如下:

```C++
#include "foo/public/fooserver.h" // 优先位置

#include <sys/types.h>
#include <unistd.h>

#include <hash_map>
#include <vector>

#include "base/basictypes.h"
#include "base/commandlineflags.h"
#include "foo/public/bar.h"
```

#### 小结

1. 避免多重包含
1. 头文件尽量避免使用前置声明，直接`include`
1. 内联函数最好少于10行。类内部的函数一般会自动内联。所以某函数一旦不需要内联，其定义就不要再放在头文件里，而是放到对应的`.cc`文件里
1. 包含文件的次序除了美观之外， 最重要的是可以减少隐藏依赖，使每个头文件在“最需要编译”的地方编译。

## 作用域

#### 命名空间

> Tip: 鼓励在`.cc`文件内使用匿名命名空间或`static`声明. 使用具名的命名空间时，其名称可基于项目名或相对路径。**禁止使用using指示(using-directive e.g. using namespace foo;)**。禁止使用内联命名空间(inline namespace)。

- 定义

    命名空间将全局作用域细分为独立的， 具名的作用域， 可有效防止全局作用域的命名冲突。

- 优点

    类已经提将命名分割在不同类的作用域内， 命名空间在这基础上又封装了一层。

    举例来说， 两个不同项目的全局作用域都有一个类`Foo`， 这样在编译或运行时造成冲突。如果每个项目将代码置于不同命名空间中，`project1::Foo`和`project2::Foo`作为不同符号自然不会冲突。

    内联命名空间会自动把内部的标识符放到外层作用域，比如：

    ```C++
    namespace X {
    inline namespace Y {
    void foo();
    }  // namespace Y
    }  // namespace X
    ```

    `X::Y::foo()`与`X::foo()`彼此可代替。内联命名空间主要用来保持跨版本的 ABI 兼容性。

- 缺点

    命名空间具有迷惑性， 因为它们使得区分两个相同命名所指代的定义更加困难。

    内联命名空间很容易令人迷惑，毕竟其内部的成员不再受其声明所在命名空间的限制。内联命名空间只在大型版本控制里有用。

- 结论

    根据下文将要提到的策略合理使用命名空间。
    - 遵守`命名空间命名`中的规则。
    - 像之前的几个例子中一样，在命名空间的最后注释出命名空间的名字。
    - 用命名空间把文件包含， 以及类的前置声明**以外**的整个源文件封装起来， 以区别于其它命名空间:

        ```C++
        // .h 文件
        namespace mynamespace {

        // 所有声明都置于命名空间中
        // 注意不要使用缩进
        class MyClass {
            public:
            ...
            void Foo();
        };

        } // namespace mynamespace
        ```

        ```C++
        // .cc 文件
        namespace mynamespace {

        // 函数定义都置于命名空间中
        void MyClass::Foo() {
            ...
        }

        } // namespace mynamespace
        ```
    - 不要在命名空间`std`内声明任何东西， 包括标准库的类前置声明。在`std`命名空间声明实体是未定义的行为， 会导致如不可移植。声明标准库下的实体， 需要包含对应的头文件。
    - 不应该使用`using`指示 引入整个命名空间的标识符号。
        ```C++
        // 禁止 —— 污染命名空间
        using namespace foo;
        ```
    - 不要在头文件中使用`命名空间别名`除非显式标记内部命名空间使用。因为任何在头文件中引入的命名空间都会成为公开API的一部分。
    - 禁止用内联命名空间

#### 匿名命名空间和静态变量

> Tip: 在`.cc`文件中定义一个不需要被外部引用的变量时，可以将它们放在匿名命名空间或声明为`static`。但是不要在`.h`文件中这么做。

- 定义

    所有置于匿名命名空间的声明都具有内部链接性，函数和变量可以经由声明为`static`拥有内部链接性，这意味着你在这个文件中声明的这些标识符都不能在另一个文件中被访问。即使两个文件声明了完全一样名字的标识符，它们所指向的实体实际上是完全不同的。

- 结论

    推荐、鼓励在`.cc`中对于不需要在其他地方引用的标识符使用内部链接性声明，但是不要在`.h`中使用。

    匿名命名空间的声明和具名的格式相同，在最后注释上`namespace`:

    ```C++
    namespace {
    ...
    }  // namespace
    ```

#### 非成员函数、静态成员函数和全局函数

> Tip: 使用静态成员函数或命名空间内的非成员函数，尽量不要用裸的全局函数。将一系列函数直接置于命名空间中，不要用类的静态方法模拟出命名空间的效果，类的静态方法应当和类的实例或静态数据紧密相关。

- 优点

    某些情况下，非成员函数和静态成员函数是非常有用的，将非成员函数放在命名空间内可避免污染全局作用域。

- 缺点

    将非成员函数和静态成员函数作为新类的成员或许更有意义，当它们需要访问外部资源或具有重要的依赖关系时更是如此。

- 结论

    有时，把函数的定义同类的实例脱钩是有益的，甚至是必要的。这样的函数可以被定义成静态成员，或是非成员函数。非成员函数不应依赖于外部变量，应尽量置于某个命名空间内。相比单纯为了封装若干不共享任何静态数据的静态成员函数而创建类，不如使用`2.1命名空间`。举例而言，对于头文件`myproject/foo_bar.h`，应当使用

    ```C++
    namespace myproject {
    namespace foo_bar {
    void Function1();
    void Function2();
    }  // namespace foo_bar
    }  // namespace myproject
    ```

    而非

    ```C++
    namespace myproject {
    class FooBar {
    public:
    static void Function1();
    static void Function2();
    };
    }  // namespace myproject
    ```

    定义在同一编译单元的函数，被其他编译单元直接调用可能会引入不必要的耦合和链接时依赖；静态成员函数对此尤其敏感。可以考虑提取到新类中，或者将函数置于独立库的命名空间内。

    如果你必须定义非成员函数，又只是在`.cc`文件中使用它，可使用`匿名命名空间`或`static`链接关键字(如`static int Foo() {...}`) 限定其作用域。

#### 局部变量

> Tip: 将函数变量尽可能置于最小作用域内, 并在变量声明时进行初始化。

C++允许在函数的任何位置声明变量。我们提倡在尽可能小的作用域中声明变量，离第一次使用越近越好。这使得代码浏览者更容易定位变量声明的位置, 了解变量的类型和初始值。特别是，应使用初始化的方式替代声明再赋值, 比如:

```C++
int i;
i = f(); // 坏——初始化和声明分离
```

```C++
int j = g(); // 好——初始化时声明
```

```C++
vector<int> v;
v.push_back(1); // 用花括号初始化更好
v.push_back(2);
```

```C++
vector<int> v = {1, 2}; // 好——v 一开始就初始化
```

属于`if`,`while`和`for`语句的变量应当在这些语句中正常地声明，这样子这些变量的作用域就被限制在这些语句中了，举例而言:

```C++
while (const char* p = strchr(str, '/')) str = p + 1;
```

有一个例外, 如果变量是一个对象, 每次进入作用域都要调用其构造函数, 每次退出作用域都要调用其析构函数。这会导致效率降低。


```C++
// 低效的实现
for (int i = 0; i < 1000000; ++i) {
    Foo f;    // 构造函数和析构函数分别调用 1000000 次!
    f.DoSomething(i);
}
```

```C++
Foo f;    // 构造函数和析构函数只调用 1 次
for (int i = 0; i < 1000000; ++i) {
    f.DoSomething(i);
}
```