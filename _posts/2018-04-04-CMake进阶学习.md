---
layout:     post
title:      CMake语言和语法
subtitle:   整理CMake常用和进阶的使用方法
date:       2018-04-05
author:     Leosocy
header-img: img/post-bg-black-series-7.jpg
catalog: true
tags:
    - CMake
---

# CMake

在项目或者工作中，会不可避免的使用到cmake来构建我们的项目，所以掌握cmake的基本语法，以及常用的和进阶的使用方法是非常重要的。

下面我们将从一个简单的`hello cmake`示例开始，一步步的深入了解cmake的用法。

***Let's Go!***

### 初探CMake，hello cmake

#### 准备工作

创建目录 /home/workspace/cmake_practice，我们之后的练习都放到这个目录的子目录下

在cmake_practice目录下创建test1

```shell
cd /home/workspace/cmake_practice
mkdir test1
cd test1
```

创建main.c以及CMakeLists.txt

main.c内容如下

```C
include <stdio.h>

int main(void)
{
    printf("Hello CMake!\n")
    return 0;
}
```

CMakeLists.txt内容如下

```cmake
PROJECT(hello-cmake)
SET(SRC_LIST main.c)
MESSAGE(STATUS "This is BINARY dir" ${PROJECT_BINARY_DIR})
MESSAGE(STATUS "This is SOURCE dir" ${PROJECT_SOURCE_DIR})
ADD_EXECUTABLE(hello-cmake ${SRC_LIST})
```

#### 开始构建

在test1目录下执行`cmake .`(. 代表当前目录)

这时会在当前目录生成`CMakeFiles`、`cmake_install.cmake`、`Makefile`等文件

我们只要关心Makefile就可以了，此时执行`make`，我们就得到了可执行文件`hello-cmake`

运行`./hello-cmake`

得到输出

`Hello CMake!`

#### 示例的语法解释

cmake的函数可以通过`cmake --help-command cmd`来查看具体的语法及使用方法

- PROJECT

    语法：
    ```cmake
    project(<projectname> [languageName1 languageName2 ... ] )
    ```
    设置项目名称并可指定工程支持的语言，支持的语言列表是可以忽略的，默认情况表示支持所有语言。这个指令隐式的定义了两个cmake变量:

        - <projectname>_BINARY_DIR
        - <projectname>_SOURCE_DIR

    因为采用的是内部编译，两个变量目前指的都是工程所在路径/home/workspace/cmake_practice/test1，后面我们会讲到外部编译，两者所指代的内容会有所不同。

    同时 cmake 系统也帮助我们预定义了 `PROJECT_BINARY_DIR` 和 `PROJECT_SOURCE_DIR`
    变量，他们的值分别跟 `<projectname>_BINARY_DIR` 与 `<projectname>_SOURCE_DIR` 一致。

    为了统一起见，建议以后直接使用 `PROJECT_BINARY_DIR`，`PROJECT_SOURCE_DIR`，即
    使修改了工程名称，也不会影响这两个变量。如果使用了
    `<projectname>_SOURCE_DIR`，修改工程名称后，需要同时修改这些变量。

- SET

    语法：
    ```cmake
    SET(<variable> <value>
        [[CACHE <type> <docstring> [FORCE]] | PARENT_SCOPE])
    ```
    在初探阶段，我们只需要知道`SET`命令可以用来显示的定义一个变量。
    比如在这个例子中`SET(SRC_LIST main.c)`，即定义了一个变量`SRC_LIST`，此变量的值为`main.c`。当然如果有多个源文件，可以定义为`SET(SRC_LIST main.c test1.c test2.c)`。

- MESSAGE

    语法：
    ```cmake
    message([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR]
            "message to display" ...)
    ```
    可选关键字决定消息的类型：
    - none          = 重要信息
    - STATUS        = 附带信息
    - WARNING       = CMake警告，继续处理
    - AUTHOR_WARNING= CMake警告（dev），继续处理
    - SEND_ERROR    = CMake错误，继续处理，但跳过生成
    - FATAL_ERROR   = CMake错误，停止处理和生成

- ADD_EXECUTABLE

    语法：
    ```cmake
    ADD_EXECUTABLE(<name> [WIN32] [MACOSX_BUNDLE]
                    [EXCLUDE_FROM_ALL]
                    source1 source2 ... sourceN)
    ```
    用于生成可执行的文件，源文件列表为`SRC_LIST`定义的源文件。在本例中我们使用`${}`来引用变量，这个cmake的变量使用方式。

#### 基本语法规则

本例中使用的基本语法规则有：

1. 变量使用`${}`方式取值，但是在`IF`控制语句中是直接使用变量名
1. COMMAND(param1 param2 ...)，参数间用*空格*或者*分号*分隔

    e.g.
    - ADD(hello-cmake main.c func.c)
    - ADD(hello-cmake main.c;func.c)
1. command是大小写无关的，但是参数和变量是大小写敏感的

#### 内部构建与外部构建

在本例中我们使用的是内部构建，即在`CMakeLists.txt`同级的目录下执行`cmake .`。内部构建会在SOURCE_DIR下生成很多临时的中间文件，不方便删除，也影响的源代码的阅读。

所以我们推荐外部构建，所谓外部构建就是在一个单独的文件夹下面执行cmake，生成的中间文件和结果都在此文件夹下。

对于本例，使用外部构建过程如下：

1. 首先清除test1目录下除`main.c`、`CMakeLists.txt`外的所有文件及文件夹，最关键的是CMakeCache.txt，如果不清除cache，还是会构建到之前的构建目录下。
1. 在test1目录下创建build文件夹
1. 进入build文件夹，执行`cmake ..`(`..`代表上一层目录，即CMakeLists所在的文件夹)
1. 运行make，即可在build文件夹下生成对应的可执行文件

上述过程即为out-of-source外部编译。一个最大的好处是，对于原有的工程没有任何影响，所有动作全部发生在编译目录。

通过外部编译进行工程构建，`PROJECT_SOURCE_DIR`仍然指代工程路径，即CMakeLists所在路径，
而`PROJECT_BINARY_DIR`则指代编译路径，即`/home/workspace/cmake_practice/test1/build`。

#### 小结

本结我们通过一个简单的hello cmake示例，介绍了最基本的CMakeLists编写，以及一些基本的语法和命令用法。同时介绍了内部编译和外部编译，及外部编译的好处。

下一节我们将丰富我们的hello cmake示例，使其看起来更像一个项目。

## 更像一个项目的hello cmake

本节的目标是让上一节的hello cmake更像一个项目，我们接下来要做的是:

1. 为工程添加一个子目录，用来放置项目的源代码
1. 添加一个子目录doc，用来工程文档`hello.txt`
1. 在工程目录添加COPYRIGHT和README
1. 在工程目录添加一个run_hello_cmake.sh脚本，用来调用`hello_cmake`可执行文件
1. 将构建的结果放置构建目录的bin子目录
1. 最终安装这些文件，将`hello_cmake`二进制文件以及`run_hello_cmake.sh`安装至`/usr/bin`目录下，将doc目录下的文件以及COPYRIGHT、README安装至`/usr/share/doc/cmake_practice/test1`目录下

#### 准备工作

在`/home/workspace/cmake_practice`目录下建立`test2`目录，将上一节中的`main.c CMakeLists.txt`拷贝到test2目录

#### 添加子目录src

```shell
mkdir src
mv main.c src
```

现在工程中有一个子目录`src`以及`CMakeLists.txt`。进入子目录，添加CMakeList如下

```cmake
ADD_EXECUTABLE(hello_cmake main.c)
```

将test2工程的CMakeLists修改为

```cmake
PROJECT(hello-cmake)
ADD_SUBDIRECTORY(src bin)
```

然后建立build目录，进入build，执行`cmake .. & make`，构建完成后，目标文件hello-cmake位于`build/bin`目录下。

#### 语法解释

- ADD_SUBDIRECTORY

    语法：
    ```cmake
    ADD_SUBDIRECTORY(source_dir [binary_dir]
                    [EXCLUDE_FROM_ALL])
    ```
    用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置。

    `EXCLUDE_FROM_ALL`参数的含义是将这个目录从编译过程中排除，比如，工程的`example`，可能需要工程构建完成之后，再进入`example`目录单独进行构建。

上面的例子定义了将src子目录加入工程，并指定了编译输出路径为bin目录。如果不指定bin目录，那么编译的结果都将存放在build/src目录

#### 换个地方保存目标二进制

我们可以通过SET指令重新定义`EXECUTABLE_OUTPUT_PATH`和`LIBRARY_OUTPUT_PATH`变量，来指定最终的目标二进制的位置(指最终生成的 hello_cmake或者最终的共享库，不包含编译生成的中间文件)

```cmake
SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_PATH}/bin)
SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_PATH}/lib)
```

在第一节我们提到了`<projectname>_BINARY_DIR`和`PROJECT_BINARY_DIR`变量，他们指的编译发生的当前目录，如果是内部编译，就相当于`PROJECT_SOURCE_DIR`也就是工程代码所在目录，如果是外部编译，指的是外部编译所在目录，也就是本例中的`build`目录。

所以，上面两个指令分别定义了：可执行二进制的输出路径为`build/bin`和库的输出路径为`build/lib`。

至于将这两条指令写在工程的CMakeLists中还是src目录下的CMakeList，只需要按照一个原则：在哪里`ADD_EXECUTABLE`或`ADD_LIBRARY`，如果需要改变目标存放的路径，就在其上加入上述定义。

#### 如何安装

安装的需要有两种，一种是从代码编译后直接`make install`安装，一种是打包时的指定目录安装。

那我们的hello_cmake应该怎么进行安装呢？

这里我们要用到一个新的cmake指令`INSTALL`和一个非常有用的变量`CMAKE_INSTALL_PREFIX`

- `CMAKE_INSTALL_PREFIX`变量类似于configure脚本的--prefix，常见的使用方法形如：

    `cmake -DCMAKE_INSTALL_PREFIX=/usr .`
- `INSTALL`指令用于定义安装规则，安装的内容可以包括
    1. 目标二进制
    1. 动态库
    1. 静态库
    1. 文件、目录、脚本

INSTALL指令包含了各种安装类型，我们需要一个个分开解释

- 目标文件的安装

    语法：
    ```cmake
    install(TARGETS targets...
            [[ARCHIVE|LIBRARY|RUNTIME]
            [DESTINATION <dir>]
            [PERMISSIONS permissions...]
            [CONFIGURATIONS [Debug|Release|...]]
            [COMPONENT <component>]
            [OPTIONAL]
            ] [...])
    ```
    参数中的`TARGETS`后面跟的就是我们通过`ADD_EXECUTABLE`或者`ADD_LIBRARY`定义的目标文件，可能是可执行二进制、动态库、静态库。

    目标类型也就相对应的有三种，`ARCHIVE`特指静态库，`LIBRARY`特指动态库，`RUNTIME`特指可执行目标二进制。

    `DESTINATION`定义了安装的路径，如果路径以/开头，那么指的是绝对路径，这时候`CMAKE_INSTALL_PREFIX`其实就无效了。如果你希望使用`CMAKE_INSTALL_PREFIX`来定义安装路径，就要写成相对路径，即不要以/开头，那么安装后的路径就是`${CMAKE_INSTALL_PREFIX}/<DESTINATION 定义的路径>`

    e.g.

    ```cmake
    install(TARGETS myExe mySharedLib myStaticLib
            RUNTIME DESTINATION bin
            LIBRARY DESTINATION lib
            ARCHIVE DESTINATION lib/static)
    ```

    将会把

    `myExe`安装到`${CMAKE_INSTALL_PREFIX}/bin`
    `mySharedLib`安装到`${CMAKE_INSTALL_PREFIX}/lib`
    `myStaticLib`安装到`${CMAKE_INSTALL_PREFIX}/lib/static`

- 普通文件的安装

    语法：
    ```cmake
    install(FILES files... DESTINATION <dir>
            [PERMISSIONS permissions...]
            [CONFIGURATIONS [Debug|Release|...]]
            [COMPONENT <component>]
            [RENAME <name>] [OPTIONAL])
    ```

    可用于安装一般文件，并可以指定访问权限，文件名是此指令所在路径下的相对路径。如果默认不定义权限`PERMISSIONS`，安装后的权限为：

    `OWNER_WRITE`, `OWNER_READ`, `GROUP_READ`,和 `WORLD_READ`，即 644 权限

- 非目标文件的

    语法：
    ```cmake
    install(PROGRAMS files... DESTINATION <dir>
            [PERMISSIONS permissions...]
            [CONFIGURATIONS [Debug|Release|...]]
            [COMPONENT <component>]
            [RENAME <name>] [OPTIONAL])
    ```

    跟上面的 FILES 指令使用方法一样，唯一的不同是安装后权限为:
`OWNER_EXECUTE`, `GROUP_EXECUTE`, 和 `WORLD_EXECUTE`，即 755 权限

- 目录的安装

    语法：
    ```cmake
    install(DIRECTORY dirs... DESTINATION <dir>
            [FILE_PERMISSIONS permissions...]
            [DIRECTORY_PERMISSIONS permissions...]
            [USE_SOURCE_PERMISSIONS] [OPTIONAL]
            [CONFIGURATIONS [Debug|Release|...]]
            [COMPONENT <component>] [FILES_MATCHING]
            [[PATTERN <pattern> | REGEX <regex>]
            [EXCLUDE] [PERMISSIONS permissions...]] [...])
    ```

    这里主要介绍其中的`DIRECTORY`、`PATTERN`、`PERMISSIONS`参数。

    - DIRECTORY：后面链接的是所在source目录的相对路径。但是abc和abc/有很大区别。如果目录名不以/结尾，那么这个目录将被安装为目标路径下的abc；如果目录名以/结尾，代表将这个目录中的内容安装到目标路径，但不包括这个目录本身。
    - PATTERN：用于使用正则表达式进行过滤，`PERMISSIONS`用于指定PATTERN过滤后的文件权限。

    e.g.
    ```cmake
    INSTALL(DIRECTORY icons scripts/ DESTINATION share/myproj
            PATTERN "CVS" EXCLUDE
            PATTERN "scripts/*"
            PERMISSIONS OWNER_EXECUTE OWNER_WRITE OWNER_READ
                GROUP_EXECUTE GROUP_READ)
    ```
    这条指令的执行结果是：
    将`icons `目录安装到`<prefix>/share/myproj`，将`scripts/`中的内容安装到`<prefix>/share/myproj`不包含目录名为 CVS 的目录，对于 `scripts/*`文件指定权限为OWNER_EXECUTE OWNER_WRITE OWNER_READ GROUP_EXECUTE GROUP_READ.

- 安装时CMAKE脚本的执行

    语法：
    ```cmake
    install([[SCRIPT <file>] [CODE <code>]] [...])
    ```

    SCRIPT参数用于在安装时调用cmake脚本文件（`也就是<abc>.cmake`文件）CODE 参数用于执行CMAKE指令，必须以双引号括起来。比如：
    `INSTALL(CODE "MESSAGE(\"Sample install message.\")")`

#### 让我们的hello cmake支持安装

安装本节开始的要求，下面改写各个目录的CMakeLists

1. 安装COPYRIGHT/README，直接修改主工程文件CMakeLists.txt，加入以下指令：`INSTALL(FILES COPYRIGHT README DESTINATION share/doc/cmake_practice/test2)`
1. 安装`hello_cmake`、`run_hello_cmake.sh`，修改主工程文件CMakeLists.txt，加入以下指令：`INSTALL(PROGRAMS run_hello_cmake.sh DESTINATION bin)`；修改src目录下CMakeLists.txt，加入以下命令：`INSTALL(PROGRAMS ${PROJECT_BINARY_DIR}/bin/hello_cmake DESTINATION bin)`
1. 安装doc中的hello.txt，这里有两种方式：一是通过在 doc 目录建立CMakeLists.txt并将`doc`目录通过`ADD_SUBDIRECTORY`加入工程来完成。另一种方法是直接在工程目录通过`INSTALL(DIRECTORY 来完成)`。我们来尝试后者，顺便演示一下`DIRECTORY`的安装。因为`hello.txt`要安装到`/<prefix>/share/doc/cmake_practice/test2`，所以我们不能直接安装整个doc目录，这里采用的方式是安装doc目录中的内容，也就是使用"doc/"在工程文件中添加`INSTALL(DIRECTORY doc/hello.txt DESTINATION share/doc/cmake_practice/test2)`

如果没有定义`CMAKE_INSTALL_PREFIX`，会默认安装到/usr/local下

#### 小结

本小节主要描述了如何在工程中使用多目录、各种安装指令以及`CMAKE_INSTALL_PREFIX`变量。

在下一小节，我们将探讨如何在cmake中构建动态库和静态库，以及如何使用外部头文件和外部共享库。

## 静态库与动态库

静态库与动态库的创建知识点并不多，主要新引入了一个新的命令如下：

```cmake
ADD_LIBRARY(<name> [STATIC | SHARED | MODULE]
            [EXCLUDE_FROM_ALL]
            source1 source2 ... sourceN)
```

类型有三种：

1. `SHARED` : 动态库
1. `STATIC` : 静态库
1. `MODULE` : 在使用dyld的系统有效，如果不支持dyld，则被当作SHARED对待

`EXCLUDE_FROM_ALL`参数的意思是这个库不会被默认构建，除非有其他的组建依赖或者手工构建

#### 名字相同的动态库和静态库同时存在

在同一个CMake中，如果`ADD_LIBRARY`的target名称相同，则后一个目标会覆盖前一个目标。如果我们想让名字相同的静态库和动态库同时存在，需要用到另外一个命令：

```cmake
SET_TARGET_PROPERTIES(target1 target2 ...
                      PROPERTIES prop1 value1
                      prop2 value2 ...)
```

这条指令可以用来设置输出的名称，对于动态库，还可以用来指定`动态库版本`和`API版本`。

只需要在CMakeLists.txt中加如`SET_TARGET_PROPERTIES(hello_static PROPERTIES OUTPUT_NAME "hello")`，就可以同时得到libhello.a/libhello.so两个库了。

#### 动态库版本号

为了实现动态库版本号，我们仍然需要使用`SET_TARGET_PROPERTIES`指令。具体使用方法：`SET_TARGET_PROPERTIES(hello PROPERTIES VERSION 1.2 SOVERSION 1)`

`VERSION`指代动态库版本，`SOVERSION`指代 API 版本。

加如CMakeLists重新构建，在build目录下会生成：

```shell
libhello.so.1.2
libhello.so.1->libhello.so.1.2
libhello.so ->libhello.so.1
```

#### 安装共享库和头文件

利用上一节提到的`INSTALL`指令，我们将动态库以及静态库安装到指定的目录

```cmake
INSTALL(TARGETS hello hello_static
        LIBRARY DESTINATION lib
        ARCHIVE DESTINATION lib)
```

#### 小结

本小节，我们谈到了：

1. 如何通过`ADD_LIBRARY`指令构建动态库和静态库。
1. 如何通过`SET_TARGET_PROPERTIES`同时构建同名的动态库和静态库。
1. 如何通过`SET_TARGET_PROPERTIES`控制动态库版本
1. 最终使用上一节谈到的`INSTALL`指令来安装动态、静态库。

## 如何使用外部共享库和头文件

#### 准备

在`/home/workspace/cmake_practice`目录下建立test4目录，按照上一节，编写CMakeLists，生成自己的hello动态库静态库以及头文件，并安装到/usr/local下。

#### 源文件和CMakeLists

重复以前的步骤，建立`src`目录，编写源文件`main.c`，内容如下：

```c
#include <hello.h>
int main()
{
    print_hello();
    return 0;
}
```

编写工程主文件`CMakeLists.txt`

```cmake
PROJECT(NEWHELLO)
ADD_SUBDIRECTORY(src)
```

编写`src/CMakeLists.txt`

```cmake
ADD_EXECUTABLE(main main.c)
```

#### 外部构建

按照习惯，仍然建立 build 目录，使用 cmake ..方式构建。
过程：

```shell
cmake ..
make
```

构建失败，如果需要查看细节，可以用`make VERBOSE=1`来构建

错误输出是：

```txt
/home/workspace/cmake_practice/test4/src/main.c:1:19: fatal error: hello.h: No such file or directory
```

#### 引入头文件搜索路径

hello.h位于`/usr/local/include/hello`目录中，并没有位于系统标准的头文件路径。

为了让我们的工程能够找到`hello.h`头文件，我们需要引入一个新的指令
`INCLUDE_DIRECTORIES`，其完整语法为：

```cmake
include_directories([AFTER|BEFORE] [SYSTEM] dir1 dir2 ...)
```

这条指令可以用来向工程添加多个特定的头文件搜索路径，路径之间用空格分割，如果路径中包含了空格，可以使用双引号将它括起来，默认的行为是追加到当前的头文件搜索路径的后面。

现在我们在`src/CMakeLists.txt`中添加一个头文件搜索路径，方式很简单，加入：`INCLUDE_DIRECTORIES(/usr/local/include/hello)`

进入build目录，重新进行构建，这时找不到hello.h的错误已经消失，但是出现了一个新的错误：

```txt
main.c:(.text+0xa): undefined reference to `print_hello'
```

因为我们并没有link到共享库libhello上

#### 为target添加共享库

我们现在需要完成的任务是将目标文件链接到libhello，这里我们需要引入两个新的指令：

`LINK_DIRECTORIES`和`TARGET_LINK_LIBRARIES`

LINK_DIRECTORIES的语法是：

```cmake
link_directories(directory1 directory2 ...)
```

这个指令非常简单，添加非标准的共享库搜索路径，比如，在工程内部同时存在共享库和可执行二进制，在编译时就需要指定一下这些共享库的路径。这个例子中我们没有用到这个指令。

TARGET_LINK_LIBRARIES的语法是:

```cmake
TARGET_LINK_LIBRARIES(target library1
                      <debug | optimized> library2
                      ...)
```

这个指令可以用来为`target`添加需要链接的共享库，本例中是一个可执行文件，但是同样可以用于为自己编写的共享库添加共享库链接。

为了解决我们前面遇到的`print_hello`未定义错误，我们需要作的是向
src/CMakeLists.txt中添加如下指令：

```cmake
LINK_DIRECTORIES(/usr/local/lib)
TARGET_LINK_LIBRARIES(main hello)
```

这里的hello指的是我们上一节构建的共享库libhello。

进入build目录重新进行构建。

```shell
cmake ..
make
```

这是我们就得到了一个连接到libhello的可执行程序 main，位于 build/src目录，运行main的结果是输出：

`Hello CMake!`

让我们来检查一下`main`的链接情况：

```shell
[root@localhost src]# ldd main
        linux-vdso.so.1 =>  (0x00007ffdb59ea000)
        libhello.so.1 => /usr/local/lib/libhello.so.1 (0x00007fe24b577000)
        libc.so.6 => /lib64/libc.so.6 (0x00007fe24b18e000)
        /lib64/ld-linux-x86-64.so.2 (0x00007fe24b77a000)
```

可以清楚的看到`main`确实链接了共享库`libhello`，而且链接的是动态库
`libhello.so.1`

那如何链接到静态库呢？方法很简单：将`TARGET_LINK_LIBRRARIES`指令修改为:

`TARGET_LINK_LIBRARIES(main libhello.a)`

重新构建后再来看一下`main`的链接情况

```shell
[root@localhost src]# ldd main
        linux-vdso.so.1 =>  (0x00007fffa2597000)
        libc.so.6 => /lib64/libc.so.6 (0x00007fb216c97000)
        /lib64/ld-linux-x86-64.so.2 (0x00007fb217080000)
```

说明`main`确实链接到了静态库`libhello.a`。

#### 小结

本节我们探讨了:

- 如何通过`INCLUDE_DIRECTORIES`指令加入非标准的头文件搜索路径。
- 如何通过`LINK_DIRECTORIES`指令加入非标准的库文件搜索路径。
- 如果通过`TARGET_LINK_LIBRARIES`为库或可执行二进制加入库链接。

到这里为止，您应该基本可以使用`cmake`工作了，但是还有很多高级的话题没有探讨，比如**编译条件检查**、**编译器定义**、**平台判断**等等。

到这里，或许你可以理解前面讲到的“cmake的使用过程其实就是学习cmake语言并编写cmake程序的过程”，既然是“cmake语言”，自然涉及到变量、语法等。

下一节，我们将抛开程序的话题，看看常用的CMAKE变量以及一些基本的控制语法规则。