---
layout:     post
title:      CMake语言和语法
subtitle:   整理CMake常用和进阶的使用方法
date:       2018-04-05
author:     Leosocy
header-img: img/post-bg-black-series-7.jpg
catalog: true
tags:
    - CMake
---

# CMake

在项目或者工作中，会不可避免的使用到cmake来构建我们的项目，所以掌握cmake的基本语法，以及常用的和进阶的使用方法是非常重要的。

下面我们将从一个简单的`hello cmake`示例开始，一步步的深入了解cmake的用法。

***Let's Go!***

### 初探CMake，hello cmake

#### 准备工作

创建目录 /home/workspace/cmake_practice，我们之后的练习都放到这个目录的子目录下

在cmake_practice目录下创建test1

```shell
cd /home/workspace/cmake_practice
mkdir test1
cd test1
```

创建main.c以及CMakeLists.txt

main.c内容如下

```C
include <stdio.h>

int main(void)
{
    printf("Hello CMake!\n")
    return 0;
}
```

CMakeLists.txt内容如下

```cmake
PROJECT(hello-cmake)
SET(SRC_LIST main.c)
MESSAGE(STATUS "This is BINARY dir" ${PROJECT_BINARY_DIR})
MESSAGE(STATUS "This is SOURCE dir" ${PROJECT_SOURCE_DIR})
ADD_EXECUTABLE(hello-cmake ${SRC_LIST})
```

#### 开始构建

在test1目录下执行`cmake .`(. 代表当前目录)

这时会在当前目录生成`CMakeFiles`、`cmake_install.cmake`、`Makefile`等文件

我们只要关心Makefile就可以了，此时执行`make`，我们就得到了可执行文件`hello-cmake`

运行`./hello-cmake`

得到输出

`Hello CMake!`

#### 示例的语法解释

cmake的函数可以通过`cmake --help-command cmd`来查看具体的语法及使用方法

- PROJECT

    语法：
    ```cmake
    project(<projectname> [languageName1 languageName2 ... ] )
    ```
    设置项目名称并可指定工程支持的语言，支持的语言列表是可以忽略的，默认情况表示支持所有语言。这个指令隐式的定义了两个cmake变量:

        - <projectname>_BINARY_DIR
        - <projectname>_SOURCE_DIR

    因为采用的是内部编译，两个变量目前指的都是工程所在路径/home/workspace/cmake_practice/test1，后面我们会讲到外部编译，两者所指代的内容会有所不同。

    同时 cmake 系统也帮助我们预定义了 `PROJECT_BINARY_DIR` 和 `PROJECT_SOURCE_DIR`
    变量，他们的值分别跟 `<projectname>_BINARY_DIR` 与 `<projectname>_SOURCE_DIR` 一致。

    为了统一起见，建议以后直接使用 `PROJECT_BINARY_DIR`，`PROJECT_SOURCE_DIR`，即
    使修改了工程名称，也不会影响这两个变量。如果使用了
    `<projectname>_SOURCE_DIR`，修改工程名称后，需要同时修改这些变量。

- SET

    语法：
    ```cmake
    SET(<variable> <value>
        [[CACHE <type> <docstring> [FORCE]] | PARENT_SCOPE])
    ```
    在初探阶段，我们只需要知道`SET`命令可以用来显示的定义一个变量。
    比如在这个例子中`SET(SRC_LIST main.c)`，即定义了一个变量`SRC_LIST`，此变量的值为`main.c`。当然如果有多个源文件，可以定义为`SET(SRC_LIST main.c test1.c test2.c)`。

- MESSAGE

    语法：
    ```cmake
    message([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR]
            "message to display" ...)
    ```
    可选关键字决定消息的类型：
    - none          = 重要信息
    - STATUS        = 附带信息
    - WARNING       = CMake警告，继续处理
    - AUTHOR_WARNING= CMake警告（dev），继续处理
    - SEND_ERROR    = CMake错误，继续处理，但跳过生成
    - FATAL_ERROR   = CMake错误，停止处理和生成

- ADD_EXECUTABLE

    语法：
    ```cmake
    ADD_EXECUTABLE(<name> [WIN32] [MACOSX_BUNDLE]
                    [EXCLUDE_FROM_ALL]
                    source1 source2 ... sourceN)
    ```
    用于生成可执行的文件，源文件列表为`SRC_LIST`定义的源文件。在本例中我们使用`${}`来引用变量，这个cmake的变量使用方式。

#### 基本语法规则

本例中使用的基本语法规则有：

1. 变量使用`${}`方式取值，但是在`IF`控制语句中是直接使用变量名
1. COMMAND(param1 param2 ...)，参数间用*空格*或者*分号*分隔

    e.g.
    - ADD(hello-cmake main.c func.c)
    - ADD(hello-cmake main.c;func.c)
1. command是大小写无关的，但是参数和变量是大小写敏感的

#### 内部构建与外部构建

在本例中我们使用的是内部构建，即在`CMakeLists.txt`同级的目录下执行`cmake .`。内部构建会在SOURCE_DIR下生成很多临时的中间文件，不方便删除，也影响的源代码的阅读。

所以我们推荐外部构建，所谓外部构建就是在一个单独的文件夹下面执行cmake，生成的中间文件和结果都在此文件夹下。

对于本例，使用外部构建过程如下：

1. 首先清除test1目录下除`main.c`、`CMakeLists.txt`外的所有文件及文件夹，最关键的是CMakeCache.txt，如果不清除cache，还是会构建到之前的构建目录下。
1. 在test1目录下创建build文件夹
1. 进入build文件夹，执行`cmake ..`(`..`代表上一层目录，即CMakeLists所在的文件夹)
1. 运行make，即可在build文件夹下生成对应的可执行文件

上述过程即为out-of-source外部编译。一个最大的好处是，对于原有的工程没有任何影响，所有动作全部发生在编译目录。

通过外部编译进行工程构建，`PROJECT_SOURCE_DIR`仍然指代工程路径，即CMakeLists所在路径，
而`PROJECT_BINARY_DIR`则指代编译路径，即`/home/workspace/cmake_practice/test1/build`。

#### 小结

本结我们通过一个简单的hello cmake示例，介绍了最基本的CMakeLists编写，以及一些基本的语法和命令用法。同时介绍了内部编译和外部编译，及外部编译的好处。

下一节我们将丰富我们的hello cmake示例，使其看起来更像一个项目。

## 更像一个项目的hello cmake

本节的目标是让上一节的hello cmake更像一个项目，我们接下来要做的是:

1. 为工程添加一个子目录，用来放置项目的源代码
1. 添加一个子目录doc，用来工程文档`hello.txt`
1. 在工程目录添加COPYRIGHT和README
1. 在工程目录添加一个run_hello_cmake.sh脚本，用来调用`hello_cmake`可执行文件
1. 将构建的结果放置构建目录的bin子目录
1. 最终安装这些文件，将`hello_cmake`二进制文件以及`run_hello_cmake.sh`安装至`/usr/bin`目录下，将doc目录下的文件以及COPYRIGHT、README安装至`/usr/share/doc/cmake_practice/test1`目录下

#### 准备工作

在`/home/workspace/cmake_practice`目录下建立`test2`目录，将上一节中的`main.c CMakeLists.txt`拷贝到test2目录

#### 添加子目录src

```shell
mkdir src
mv main.c src
```

现在工程中有一个子目录`src`以及`CMakeLists.txt`。进入子目录，添加CMakeList如下

```cmake
ADD_EXECUTABLE(hello_cmake main.c)
```

将test2工程的CMakeLists修改为

```cmake
PROJECT(hello-cmake)
ADD_SUBDIRECTORY(src bin)
```

然后建立build目录，进入build，执行`cmake .. & make`，构建完成后，目标文件hello-cmake位于`build/bin`目录下。

#### 语法解释

- ADD_SUBDIRECTORY

    语法：
    ```cmake
    ADD_SUBDIRECTORY(source_dir [binary_dir]
                    [EXCLUDE_FROM_ALL])
    ```
    用于向当前工程添加存放源文件的子目录，并可以指定中间二进制和目标二进制存放的位置。

    `EXCLUDE_FROM_ALL`参数的含义是将这个目录从编译过程中排除，比如，工程的`example`，可能需要工程构建完成之后，再进入`example`目录单独进行构建。

上面的例子定义了将src子目录加入工程，并指定了编译输出路径为bin目录。如果不指定bin目录，那么编译的结果都将存放在build/src目录

#### 换个地方保存目标二进制

我们可以通过SET指令重新定义`EXECUTABLE_OUTPUT_PATH`和`LIBRARY_OUTPUT_PATH`变量，来指定最终的目标二进制的位置(指最终生成的 hello_cmake或者最终的共享库，不包含编译生成的中间文件)

```cmake
SET(EXECUTABLE_OUTPUT_PATH ${PROJECT_BINARY_PATH}/bin)
SET(LIBRARY_OUTPUT_PATH ${PROJECT_BINARY_PATH}/lib)
```

在第一节我们提到了`<projectname>_BINARY_DIR`和`PROJECT_BINARY_DIR`变量，他们指的编译发生的当前目录，如果是内部编译，就相当于`PROJECT_SOURCE_DIR`也就是工程代码所在目录，如果是外部编译，指的是外部编译所在目录，也就是本例中的`build`目录。

所以，上面两个指令分别定义了：可执行二进制的输出路径为`build/bin`和库的输出路径为`build/lib`。

至于将这两条指令写在工程的CMakeLists中还是src目录下的CMakeList，只需要按照一个原则：在哪里`ADD_EXECUTABLE`或`ADD_LIBRARY`，如果需要改变目标存放的路径，就在其上加入上述定义。

#### 如何安装

安装的需要有两种，一种是从代码编译后直接`make install`安装，一种是打包时的指定目录安装。

那我们的hello_cmake应该怎么进行安装呢？

这里我们要用到一个新的cmake指令`INSTALL`和一个非常有用的变量`CMAKE_INSTALL_PREFIX`

- `CMAKE_INSTALL_PREFIX`变量类似于configure脚本的--prefix，常见的使用方法形如：

    `cmake -DCMAKE_INSTALL_PREFIX=/usr .`
- `INSTALL`指令用于定义安装规则，安装的内容可以包括
    1. 目标二进制
    1. 动态库
    1. 静态库
    1. 文件、目录、脚本

INSTALL指令包含了各种安装类型，我们需要一个个分开解释

- 目标文件的安装

    语法：
    ```cmake
    install(TARGETS targets...
            [[ARCHIVE|LIBRARY|RUNTIME]
            [DESTINATION <dir>]
            [PERMISSIONS permissions...]
            [CONFIGURATIONS [Debug|Release|...]]
            [COMPONENT <component>]
            [OPTIONAL]
            ] [...])
    ```
    参数中的`TARGETS`后面跟的就是我们通过`ADD_EXECUTABLE`或者`ADD_LIBRARY`定义的目标文件，可能是可执行二进制、动态库、静态库。

    目标类型也就相对应的有三种，`ARCHIVE`特指静态库，`LIBRARY`特指动态库，`RUNTIME`特指可执行目标二进制。

    `DESTINATION`定义了安装的路径，如果路径以/开头，那么指的是绝对路径，这时候`CMAKE_INSTALL_PREFIX`其实就无效了。如果你希望使用`CMAKE_INSTALL_PREFIX`来定义安装路径，就要写成相对路径，即不要以/开头，那么安装后的路径就是`${CMAKE_INSTALL_PREFIX}/<DESTINATION 定义的路径>`

    e.g.

    ```cmake
    install(TARGETS myExe mySharedLib myStaticLib
            RUNTIME DESTINATION bin
            LIBRARY DESTINATION lib
            ARCHIVE DESTINATION lib/static)
    ```

    将会把

    `myExe`安装到`${CMAKE_INSTALL_PREFIX}/bin`
    `mySharedLib`安装到`${CMAKE_INSTALL_PREFIX}/lib`
    `myStaticLib`安装到`${CMAKE_INSTALL_PREFIX}/lib/static`

- 普通文件的安装

    语法：
    ```cmake
    install(FILES files... DESTINATION <dir>
            [PERMISSIONS permissions...]
            [CONFIGURATIONS [Debug|Release|...]]
            [COMPONENT <component>]
            [RENAME <name>] [OPTIONAL])
    ```

    可用于安装一般文件，并可以指定访问权限，文件名是此指令所在路径下的相对路径。如果默认不定义权限`PERMISSIONS`，安装后的权限为：

    `OWNER_WRITE`, `OWNER_READ`, `GROUP_READ`,和 `WORLD_READ`，即 644 权限

- 非目标文件的

    语法：
    ```cmake
    install(PROGRAMS files... DESTINATION <dir>
            [PERMISSIONS permissions...]
            [CONFIGURATIONS [Debug|Release|...]]
            [COMPONENT <component>]
            [RENAME <name>] [OPTIONAL])
    ```

    跟上面的 FILES 指令使用方法一样，唯一的不同是安装后权限为:
`OWNER_EXECUTE`, `GROUP_EXECUTE`, 和 `WORLD_EXECUTE`，即 755 权限

- 目录的安装

    语法：
    ```cmake
    install(DIRECTORY dirs... DESTINATION <dir>
            [FILE_PERMISSIONS permissions...]
            [DIRECTORY_PERMISSIONS permissions...]
            [USE_SOURCE_PERMISSIONS] [OPTIONAL]
            [CONFIGURATIONS [Debug|Release|...]]
            [COMPONENT <component>] [FILES_MATCHING]
            [[PATTERN <pattern> | REGEX <regex>]
            [EXCLUDE] [PERMISSIONS permissions...]] [...])
    ```