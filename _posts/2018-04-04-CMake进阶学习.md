---
layout:     post
title:      CMake语言和语法
subtitle:   整理CMake常用和进阶的使用方法
date:       2018-04-05
author:     Leosocy
header-img: img/post-bg-black-series-7.jpg
catalog: true
tags:
    - CMake
---

# CMake

在项目或者工作中，会不可避免的使用到cmake来构建我们的项目，所以掌握cmake的基本语法，以及常用的和进阶的使用方法是非常重要的。

下面我们将从一个简单的`hello cmake`示例开始，一步步的深入了解cmake的用法。

***Let's Go!***

## 初探CMake，hello cmake

### 准备工作

创建目录 /home/workspace/cmake_practice，我们之后的练习都放到这个目录的子目录下

在cmake_practice目录下创建test1

```shell
cd /home/workspace/cmake_practice
mkdir test1
cd test1
```

创建main.c以及CMakeLists.txt

main.c内容如下

```C
include <stdio.h>

int main(void)
{
    printf("Hello CMake!\n")
    return 0;
}
```

CMakeLists.txt内容如下

```cmake
PROJECT(hello-cmake)
SET(SRC_LIST main.c)
MESSAGE(STATUS "This is BINARY dir" ${PROJECT_BINARY_DIR})
MESSAGE(STATUS "This is SOURCE dir" ${PROJECT_SOURCE_DIR})
ADD_EXECUTABLE(hello-cmake ${SRC_LIST})
```

### 开始构建

在test1目录下执行`cmake .`(. 代表当前目录)

这时会在当前目录生成`CMakeFiles`、`cmake_install.cmake`、`Makefile`等文件

我们只要关心Makefile就可以了，此时执行`make`，我们就得到了可执行文件`hello-cmake`

运行`./hello-cmake`

得到输出

`Hello CMake!`

### 示例的语法解释

cmake的函数可以通过`cmake --help-command cmd`来查看具体的语法及使用方法

- PROJECT

    语法：
    ```cmake
    project(<projectname> [languageName1 languageName2 ... ] )
    ```
    设置项目名称并可指定工程支持的语言，支持的语言列表是可以忽略的，默认情况表示支持所有语言。这个指令隐式的定义了两个cmake变量:

        - <projectname>_BINARY_DIR
        - <projectname>_SOURCE_DIR

    因为采用的是内部编译，两个变量目前指的都是工程所在路径/home/workspace/cmake_practice/test1，后面我们会讲到外部编译，两者所指代的内容会有所不同。

    同时 cmake 系统也帮助我们预定义了 `PROJECT_BINARY_DIR` 和 `PROJECT_SOURCE_DIR`
    变量，他们的值分别跟 `<projectname>_BINARY_DIR` 与 `<projectname>_SOURCE_DIR` 一致。

    为了统一起见，建议以后直接使用 `PROJECT_BINARY_DIR`，`PROJECT_SOURCE_DIR`，即
    使修改了工程名称，也不会影响这两个变量。如果使用了
    `<projectname>_SOURCE_DIR`，修改工程名称后，需要同时修改这些变量。

- SET

    语法：
    ```cmake
    SET(<variable> <value>
        [[CACHE <type> <docstring> [FORCE]] | PARENT_SCOPE])
    ```
    在初探阶段，我们只需要知道`SET`命令可以用来显示的定义一个变量。
    比如在这个例子中`SET(SRC_LIST main.c)`，即定义了一个变量`SRC_LIST`，此变量的值为`main.c`。当然如果有多个源文件，可以定义为`SET(SRC_LIST main.c test1.c test2.c)`。

- MESSAGE

    语法：
    ```cmake
    message([STATUS|WARNING|AUTHOR_WARNING|FATAL_ERROR|SEND_ERROR]
            "message to display" ...)
    ```
    可选关键字决定消息的类型：
    - none          = 重要信息
    - STATUS        = 附带信息
    - WARNING       = CMake警告，继续处理
    - AUTHOR_WARNING= CMake警告（dev），继续处理
    - SEND_ERROR    = CMake错误，继续处理，但跳过生成
    - FATAL_ERROR   = CMake错误，停止处理和生成

- ADD_EXECUTABLE

    语法：
    ```cmake
    ADD_EXECUTABLE(<name> [WIN32] [MACOSX_BUNDLE]
                    [EXCLUDE_FROM_ALL]
                    source1 source2 ... sourceN)
    ```
    用于生成可执行的文件，源文件列表为`SRC_LIST`定义的源文件。在本例中我们使用`${}`来引用变量，这个cmake的变量使用方式。

### 基本语法规则

本例中使用的基本语法规则有：

1. 变量使用`${}`方式取值，但是在`IF`控制语句中是直接使用变量名
1. COMMAND(param1 param2 ...)，参数间用*空格*或者*分号*分隔

    e.g.
    - ADD(hello-cmake main.c func.c)
    - ADD(hello-cmake main.c;func.c)
1. command是大小写无关的，但是参数和变量是大小写敏感的

### 内部构建与外部构建

在本例中我们使用的是内部构建，即在`CMakeLists.txt`同级的目录下执行`cmake .`。内部构建会在SOURCE_DIR下生成很多临时的中间文件，不方便删除，也影响的源代码的阅读。

所以我们推荐外部构建，所谓外部构建就是在一个单独的文件夹下面执行cmake，生成的中间文件和结果都在此文件夹下。

对于本例，使用外部构建过程如下：

1. 首先清除test1目录下除`main.c`、`CMakeLists.txt`外的所有文件及文件夹，最关键的是CMakeCache.txt，如果不清除cache，还是会构建到之前的构建目录下。
1. 在test1目录下创建build文件夹
1. 进入build文件夹，执行`cmake ..`(`..`代表上一层目录，即CMakeLists所在的文件夹)
1. 运行make，即可在build文件夹下生成对应的可执行文件

上述过程即为out-of-source外部编译。一个最大的好处是，对于原有的工程没有任何影响，所有动作全部发生在编译目录。

通过外部编译进行工程构建，`PROJECT_SOURCE_DIR`仍然指代工程路径，即CMakeLists所在路径，
而`PROJECT_BINARY_DIR`则指代编译路径，即`/home/workspace/cmake_practice/test1/build`。

### 小结

本结我们通过一个简单的hello cmake示例，介绍了最基本的CMakeLists编写，以及一些基本的语法和命令用法。同时介绍了内部编译和外部编译，及外部编译的好处。

下一节我们将丰富我们的hello cmake示例，使其看起来更像一个项目。
